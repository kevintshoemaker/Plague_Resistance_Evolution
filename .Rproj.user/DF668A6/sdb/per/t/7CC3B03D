{
    "collab_server" : "",
    "contents" : "\n\n\n########################\n# FUNCTIONS!!\n########################\n\n\n############\n## DO PLAGUE (determine which populations currently have plague given statistical model)\n############\n\ndoPlague <- function(PlagueRaster=PlagueRaster,PopArray=PopArray){ \n  \n  nPlagueNeighbors <- focal(PlagueRaster, w=matrix(1, nc=MAXDISPERSAL_CELLS, nr=MAXDISPERSAL_CELLS),na.rm=T)\n  \n  # plot(PlagueRaster)\n  # plot(nPlagueNeighbors)\n  \n  newdf <- data.frame(\n    dens = PopArray@data@values,\n    plaguepops = nPlagueNeighbors@data@values\n  )\n  \n  # newdf <- data.frame(\n  #   dens=0,\n  #   plaguepops=0\n  # )\n  \n  prob <- plogis(as.numeric(predict(PlagueModel,newdata=newdf)))\n  ProbRaster <- setValues(PlagueRaster,values=prob)\n  ndx <- !is.na(prob)\n  prediction <- prob\n  prediction[ndx] <- rbinom(length(which(ndx)),1,prediction[ndx])\n  PlagueRaster <- setValues(PlagueRaster,values=prediction)   # set the plagueraster according to the statistical model\n  return(PlagueRaster)\n}\n\n############\n## GET PLAGUE MODEL\n############\n\nGetPlagueModel <- function(){\n  BETADENS <- 0.005\n  BETAPLAGUE <- 0.9\n  INTERACTION <- 0.03\n  INTERCEPT <- -6\n  \n  faken <- 1000\n  fakedens <- seq(0,200,length=faken)\n  fakeplaguepops <- sample(c(0:5),faken,replace=T)\n  fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)\n  \n  plot(fakeplagueprob~fakeplaguepops)\n  #plot(fakeplagueprob~fakedens)\n  fakeplague <- rbinom(faken,1,fakeplagueprob)\n  \n  dataFrame <- data.frame(plague=fakeplague,dens=fakedens,plaguepops=fakeplaguepops)\n  \n  plaguemodel <- glm(plague~1+plaguepops*dens,data=dataFrame,family=\"binomial\")\n  \n  plogis(predict(plaguemodel,newdata=data.frame(dens=c(10:10),plaguepops=c(1:10))))\n  \n  summary(plaguemodel)\n  \n  return(plaguemodel)\n}\n\n############\n## INITIALIZE DISPERSAL STRUCTURES\n############\n\nInitializeDispersal <- function(){\n  MAXDISPERSAL_CELLS <<- floor(MAXDISPERSAL/CELLWIDTH)\n  MAXDISPERSAL_CELLS_PLAGUE <<- floor(MAXDISPERSAL_PLAGUE/CELLWIDTH)\n  MAXDISPERSAL <<- MAXDISPERSAL_CELLS*CELLWIDTH\n  MAXDISPERSAL_PLAGUE <<- MAXDISPERSAL_CELLS_PLAGUE*CELLWIDTH\n  \n  DispMask <<- list()\n  DispKernel <<- list()\n  i=\"noPlague\"\n  for(i in c(\"noPlague\",\"plague\")){\n    if(i==\"noPlague\"){ maxdispcells = MAXDISPERSAL_CELLS ; maxdisp = MAXDISPERSAL} \n    if(i==\"plague\") {maxdispcells = MAXDISPERSAL_CELLS_PLAGUE ; maxdisp = MAXDISPERSAL_PLAGUE}\n    tempDispMask <- matrix(1,nrow=((maxdispcells*2)+1),ncol=((maxdispcells*2)+1))     # dispersal mask defines where it is possible to go...\n    #DispMask_Plague <- matrix(1,nrow=((MAXDISPERSAL_CELLS_PLAGUE*2)+1),ncol=((MAXDISPERSAL_CELLS_PLAGUE*2)+1))     # dispersal mask defines where it is possible to go...\n    \n    # exclude values greater than the max dispersal distance from the dispersal kernel \n    xs <- seq(HALFCELLWIDTH,maxdisp*2+HALFCELLWIDTH,by=CELLWIDTH)\n    ys <- seq(HALFCELLWIDTH,maxdisp*2+HALFCELLWIDTH,by=CELLWIDTH)\n    \n    focalcell <- ((length(xs)-1)/2)+1\n    focalx <- xs[focalcell]\n    focaly <- ys[focalcell]\n    col=1;row=1\n    for(col in 1:length(xs)){\n      for(row in 1:length(ys)){\n        dist <- sqrt((xs[col]-focalx)^2 + (ys[row]-focaly)^2)\n        if(dist>maxdisp) tempDispMask[row,col] = NA \n      }\n    }\n    tempDispKernel <- tempDispMask   # for now, dispersal kernel is uniform    ; dispersal kernel defines where pdogs go if they lose a home colony\n    #DispKernel_Plague <- DispMask_Plague\n    DispMask[[i]] <<- tempDispMask\n    DispKernel[[i]] <<- tempDispKernel\n    \n  }\n  \n  # set up structures for colony expansion- individuals move to neighboring cells first..   [note: for now, donuts obey only the non-plague max dispersal]\n  \n  donuts <<- list()\n  for(j in c(\"noPlague\",\"plague\")){\n    if(j==\"noPlague\"){ maxdispcells = MAXDISPERSAL_CELLS ; maxdisp = MAXDISPERSAL} \n    if(j==\"plague\") {maxdispcells = MAXDISPERSAL_CELLS_PLAGUE ; maxdisp = MAXDISPERSAL_PLAGUE}\n    donuts[[j]] <<- list()\n    donut_template <- matrix(0,nrow=((maxdispcells*2)+1),ncol=((maxdispcells*2)+1),byrow=T)\n    newseq <- c(-maxdispcells:maxdispcells)\n    \n    ndx <- which(abs(newseq)<1)\n    donutsZero <- donut_template\n    donutsZero[ndx,ndx] <- 1 \n    i=1\n    for(i in 1:maxdispcells){\n      ndx <- which(abs(newseq)<(i+1))\n      donuts[[j]][[i]] <<- donut_template\n      donuts[[j]][[i]][ndx,ndx] <<- 1\n      donuts[[j]][[i]] <<- donuts[[j]][[i]] - donutsZero\n      #donuts[[i]] <- apply(donuts[[i]],c(1,2),function(t) ifelse(t==0,NA,t)) \n      donutsZero <- donuts[[j]][[i]] + donutsZero\n    }\n  }\n  \n  donuts[[j]] <<- lapply(donuts[[j]],function(k) apply(k,c(1,2),function(t) ifelse(t==0,NA,t)))\n  \n  # donuts[['noPlague']][[4]]\n}\n\n\n\n############\n## INITIALIZE LANDSCAPE (patches of habitat)\n############\n\n#?raster\n\nInitializeLandscape <- function(solid=F){\n  templateRaster <- raster(nrows=NROWS, ncols=NCOLS, xmn=0, xmx=CELLWIDTH*NROWS,ymn=0, ymx=CELLWIDTH*NCOLS,vals=NA)    # template raster\n  # plot(templateRaster)\n  \n  if(solid){\n    patchRaster <<- setValues(templateRaster,1) \n  }else{\n  \n  # use utility function from secr package to initialize landscape... \n    tempgrid <- make.grid(nx = NCOLS, ny = NROWS, spacing = CELLWIDTH,\n                          detector = \"single\", originxy = c(0,0), hollow = F,\n                          ID = \"alphay\")\n    \n    # plot(tempgrid)  \n    \n    tempmask <- make.mask(traps=tempgrid, buffer = HALFCELLWIDTH, spacing = CELLWIDTH, nx = NCOLS, ny = NROWS, type =\n                            c(\"traprect\"))\n    \n    # plot(tempmask)\n    \n    temppatches <- randomHabitat(mask=tempmask, p = 0.4, A = PER_SUITABLE, directions = 4, minpatch = 20,\n                                 drop = FALSE, covname = \"habitat\", plt = FALSE)\n    \n    #patchRaster <- templateRaster\n    #patchvals <- as.vector(t(as.matrix(covariates(temppatches)$habitat)))\n    patchRaster <<- setValues(templateRaster,values=covariates(temppatches)$habitat)\n    \n    patchRaster <<- reclassify(patchRaster,rcl=c(-Inf,0.5,NA, 0.6,Inf,1))   # raster of habitat patches\n    # plot(patchRaster) \n  }\n  # extend patch raster to go outside the landscape bounds to the max dispersal distance...\n  maxdisp <- max(MAXDISPERSAL_CELLS,MAXDISPERSAL_CELLS_PLAGUE)\n  patchRaster <<- extend(patchRaster,maxdisp,value=NA)\n  \n  #patchMatrix <- as.matrix(newraster)    # matrix of habitat patches\n  \n  KRaster <<- patchRaster * MAXDENS     # matrix of carrying capacity\n  # plot(KRaster)\n  \n  patchIDRaster <<- clump(patchRaster,directions=4,gaps=F)   # determine unique ID for each patch... \n  # plot(patchIDRaster)\n  \n  nPatches <<- cellStats(patchIDRaster,\"max\")   # number of patches in the landscape\n  \n  nCells <<- ncell(patchRaster)\n  \n  # Data frame of coordinates for all non-na cells\n  # focalCells <- which(!is.na(patchRaster@data@values))\n  # xy_df <- data.frame(\n  #   xyFromCell(patchRaster,focalCells)\n  # )\n  # \n  # head(xy_df)\n  \n  # extent- in terms of cell centroids... (used for dispersal)\n  MINX <<- patchRaster@extent@xmin+HALFCELLWIDTH\n  MAXX <<- patchRaster@extent@xmax-HALFCELLWIDTH\n  MINY <<- patchRaster@extent@ymin+HALFCELLWIDTH\n  MAXY <<- patchRaster@extent@ymax-HALFCELLWIDTH\n  \n  FULLEXTENT <<- extent(MINX,MAXX,MINY,MAXY)\n}\n\n\n\n##################\n# DISPERSAL FUNCTIONS\n##################\n#  NOTE: there is a baseline dispersal, plus any individuals that are crowded out... \n#    individuals that are crowded out are dictated by the snuggle function\n#    individuals that are baseline dispersers are governed by the kernel\n\n# NOTE: need to deal with boundary conditions... \n\n\n###################\n# Add (or subtract) individuals from cells during dispersal phase\n\nUpdateAbund <- function(focalxy=xy, stack=newStack, df=toAdd_df){\n  #browser()\n  focalndx <- cellFromXY(PopArray,focalxy)\n  ndx <- cellFromXY(PopArray,df[,c(\"x\",\"y\")])\n  indiv <- df[,3]   # individuals to add\n  names <- names(stack)\n  i=names[2]\n  for(i in names){\n    if(i==\"PopArray\"){\n      Add <- indiv\n    }else{\n      Add <- eval(parse(text=i))[focalndx]*indiv   # otherwise, add to the total in each cell for averaging (evolving!)\n      # add the focal value of evolving layers to the surrounding cells   [change this!!!]\n    }\n    stack[[i]][ndx] <- stack[[i]][ndx]+Add\n  }\n  return(stack)\n}\n\n\n##################\n# Update the raster stack for dispersal and save key layers to the global environment\n\nUpdateStack <- function(stack=newStack){\n  names <- names(stack)\n  # i=names[2]\n  for(i in names){\n    if(i!=\"PopArray\"){\n      ndx <- which(stack[[\"PopArray\"]]@data@values>0)  #only consider cells with actual individuals\n      stack[[i]][ndx] <- stack[[i]][ndx]/stack[['PopArray']][ndx]    # get the population mean for key evolving variables\n      stack[[i]][stack[[\"PopArray\"]]@data@values==0] <- 0\n      assign(x=i,value=stack[[i]], envir = .GlobalEnv)   # assign the variable to the global environment\n    }\n  }\n  #return(stack)\n}\n\n##########\n# Determine the dispersal rates from this cell (depends on plague status)\n\nGetDispersalRates <- function(plagueStatus=\"noPlague\"){\n  if(plagueStatus==\"noPlague\") {maxdisp<<-MAXDISPERSAL;disprate<<-BASELINE_DISPERSAL;maxdispcells<<-MAXDISPERSAL_CELLS}\n  if(plagueStatus==\"plague\") {maxdisp<<-MAXDISPERSAL_PLAGUE;disprate<<-PLAGUE_DISPERSAL;maxdispcells<<-MAXDISPERSAL_CELLS_PLAGUE}\n}\n\n\n#############\n# DEFINE THE NEIGHBORHOOD TO WHICH PDOGS COULD MOVE\n#############\n\nmakeNeighborhoodRasters <- function(newStack=newStack,plagueStatus=\"noPlague\",xy=xy){\n  mask=DispMask[[plagueStatus]]\n  kernel=DispKernel[[plagueStatus]]\n  GetDispersalRates(plagueStatus) # already done... \n  neighborhood.extent <- extent(xy$x-maxdisp-HALFCELLWIDTH,\n                                xy$x+maxdisp+HALFCELLWIDTH,\n                                xy$y-maxdisp-HALFCELLWIDTH,\n                                xy$y+maxdisp+HALFCELLWIDTH)\n  neighborhood_raster <- crop(newStack[[\"PopArray\"]],neighborhood.extent)    # possible cells to move to and from [TODO: change this to current status, not former]\n  #neighborhood_raster <- neighborhood_raster - (neighborhood_raster*disprate) # make sure that there is space for incoming dispersers [revisit this]\n  \n  ################\n  # Make a neighborhood mask\n  \n  vals <- as.vector(t(mask))  # convert disp mask to a vector format\n  #vals[vals==0] <- NA\n  #neighborhood_kernel_raster <- neighborhood_raster \n  length(vals)\n  ncell(neighborhood_raster)\n  neighborhood_mask_raster <- setValues(neighborhood_raster,values=vals)  # NOTE: this could be a dispersal kernel\n  \n  ###############\n  # Make a neighborhood kernel\n  vals <- as.vector(t(kernel))\n  neighborhood_kernel_raster <- setValues(neighborhood_raster,values=vals)\n  \n  #     plot(neighborhood_raster)\n  #     plot(neighborhood_mask_raster)\n  neighborhood_raster <- neighborhood_raster * neighborhood_mask_raster  # abundance in real neighborhood (assuming edge is hard barrier)  \n  \n  neighborhood_mask_raster <- reclassify(neighborhood_raster,c(-Inf,Inf,1))\n  \n  neighborhood_kernel_raster <- neighborhood_kernel_raster*neighborhood_mask_raster\n  \n  # names(neighborhoodRasters)\n  freeSpace_raster <- reclassify(MAXABUND-neighborhood_raster,rcl=c(-Inf,0,0))  # indicator of how much \"free space\" is available for cells in the neighborhood\n  # plot(freeSpace_raster)\n  \n  neighborhood_stack <- stack(list(\n    maskRaster = neighborhood_mask_raster,\n    kernelRaster = neighborhood_kernel_raster,\n    abundRaster = neighborhood_raster,\n    freeSpaceRaster = freeSpace_raster\n  ))\n  \n  return(neighborhood_stack)\n}\n\n\n####################\n# FUNCTION FOR SPREADING OUT THE POPULATION\n####################\n#account for the snuggle effect...\n\n#############################\n# DISPERSAL MODE #1: CLUSTER WITH EXISTING POPULATION\n#############################\n\n#names(neighborhoodRasters)\n\nSpreadOut <- function(newStack=newStack,leave_snuggle=leave_snuggle,\n                      plagueStatus=plagueStatus,\n                      xy=xy,\n                      neighborhood_raster=neighborhoodRasters[['abundRaster']],\n                      neighborhood_mask_raster=neighborhoodRasters[['maskRaster']],\n                      freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']]){\n  GetDispersalRates(plagueStatus=plagueStatus) \n  updatedStack <- newStack\n  i=2\n  #toAdd <- data.frame(x=numeric(0),y=numeric(0))\n  for(i in 1:maxdispcells){\n    donutraster <- setValues(neighborhood_raster,values=donuts[[plagueStatus]][[i]])\n    # plot(donutraster)\n    #tempmask <- reclassify(neighborhood_raster,rcl=c(-Inf,Inf,1))  # NA,NA,0, \n    #browser()\n    donutraster <- donutraster*neighborhood_mask_raster  # all non-NA cells within the donut\n    #         plot(donutraster+tempmask)\n    #         plot(donutraster)\n    #         plot(tempmask)\n    #         plot(neighborhood_mask_raster)\n    #         plot(donutraster==tempmask)\n    #         plot(freeSpace_raster)\n    temp <- freeSpace_raster*donutraster\n    #plot(reclassify(neighborhood_raster,rcl=c(-Inf,Inf,1)))\n    #temp <- reclassify(MAXABUND-temp,rcl=c(-Inf,0,0))   # REVISIT!\n    # plot(temp)\n    freeSpace <- temp@data@values[which(temp@data@values>0)]\n    # if there is free space... then put individuals in that space... \n    if(length(freeSpace)>0){\n      toAdd_df <- as.data.frame(xyFromCell(temp,which(temp@data@values>0))) # cells with empty space to go    \n      # allocate those individuals \n      #toAdd_df$indiv <- 0\n      toAdd <- min(sum(freeSpace),leave_snuggle)\n      toAdd_df$indiv <- rmultinom(1,toAdd,prob=freeSpace)[,1]    # disperser individuals to add to each cell\n      dispndx <- which(toAdd_df$indiv>0)\n      updatedStack <- UpdateAbund(focalxy=xy,stack=updatedStack,df=toAdd_df[dispndx,])  # add these disperser individuals and update the evolving factors\n      leave_snuggle <- leave_snuggle-toAdd   # remove these individuals from the \"leave\" pool\n      #ndx <- cellFromXY(newPop,toAdd_df[,c(\"x\",\"y\")])\n      #newPop[ndx] <- newPop[ndx]+toAdd_df$indiv\n      # plot(newPop)\n      # plot(updatedStack[[\"PopArray\"]])\n      \n      \n    } # end if free space available \n    \n    # if all individuals have been dispersed, then stop the loop\n    if(leave_snuggle<=0) break\n    #if(i==MAXDISPERSAL_CELLS) # don't need to kill off the existing individuals explicitly... they automatically don't get propagated... \n  } #end loop through donuts\n  return(updatedStack)\n}\n\n\n####################\n# FUNCTION FOR PERFORMING LONG-DISTANCE DISPERSAL\n####################\n#account for the snuggle effect...\n\n#############################\n# DISPERSAL MODE #2: LONG-DISTANCE (not density dependent...)  [mostly redundant with above, move into function!]  [these dispersers, unlike the snuggle dispersers, are forced to integrate with the recipient populations]\n############################# \n\n#names(neighborhoodRasters)\nLongDistanceDispersal <- function(newStack=newStack,leave_kernel=leave_kernel,\n                                  plagueStatus=plagueStatus,\n                                  xy=xy,\n                                  neighborhood_raster=neighborhoodRasters[['abundRaster']],\n                                  freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']],\n                                  neighborhood_kernel_raster=neighborhoodRasters[['kernelRaster']]){\n  \n  # disperse via the kernel...\n  #leave_kernel\n  #plot(neighborhood_raster)\n  #plot(reclassify(neighborhood_raster,rcl=c(-Inf,Inf,1)))\n  \n  GetDispersalRates(plagueStatus=plagueStatus)\n  \n  freeSpace <-  freeSpace_raster@data@values[which(freeSpace_raster@data@values>0)]\n  if(length(freeSpace)>0){\n    freeSpace <- (freeSpace+1)/max(freeSpace)  # convert to weighting factor in line with kernel\n    toAdd_df <- as.data.frame(xyFromCell(freeSpace_raster,which(freeSpace_raster@data@values>0))) # cells with empty space and habitat to go   \n    kernel.weights <- neighborhood_kernel_raster[cellFromXY(neighborhood_kernel_raster,toAdd_df[,c(1,2)])] \n    # allocate those individuals \n    #toAdd_df$indiv <- 0\n    #toAdd <- min(sum(freeSpace),leave_kernel)\n    toAdd_df$indiv <- rmultinom(1,leave_kernel,prob=freeSpace*kernel.weights)[,1]    # disperser individuals to add to each cell (favor cells that have more free space...)\n  }else{  # if there is no free space, then force dispersal anyway\n    toAdd_df <- as.data.frame(xyFromCell(neighborhood_raster,which(!is.na(neighborhood_raster@data@values)))) # cells with habitat to go   \n    kernel.weights <- neighborhood_kernel_raster[cellFromXY(neighborhood_kernel_raster,toAdd_df[,c(1,2)])] \n    # allocate those individuals \n    #toAdd_df$indiv <- 0\n    #toAdd <- min(sum(freeSpace),leave_kernel)\n    toAdd_df$indiv <- rmultinom(1,leave_kernel,prob=kernel.weights)[,1]    # disperser individuals to add to each cell (favor cells that have more free space...)\n  }\n  dispndx <- which(toAdd_df$indiv>0)\n  updatedStack <- UpdateAbund(focalxy=xy,stack=newStack,df=toAdd_df[dispndx,])  # add these disperser individuals and update the accumulating raster stack\n  #leave_kernel <- leave_kernel-toAdd   # remove these individuals from the \"leave\" pool\n  #ndx <- cellFromXY(newPop,toAdd_df[,c(\"x\",\"y\")])\n  #newPop[ndx] <- newPop[ndx]+toAdd_df$indiv\n  # plot(newPop)\n  return(updatedStack)\n}\n\n\n\n####################\n# FUNCTION FOR PERFORMING CONSOLIDATION OF LOW-DENSITY POPULATIONS\n####################\n\n###################\n# DISPERSAL MODE #3: CONSOLIDATE AROUND NEW FOCI (establish new colonies)\n###################\n\n#names(neighborhoodRasters)\nConsolidatePops <- function(newStack=newStack,leave=leave,\n                            #newFociRaster=newFociRaster,\n                            plagueStatus=plagueStatus,\n                            xy=xy,\n                            newFociRaster=newFociRaster,\n                            neighborhood_raster=neighborhoodRasters[['abundRaster']],\n                            neighborhood_mask_raster=neighborhoodRasters[['maskRaster']]){\n  \n  \n  GetDispersalRates(plagueStatus=plagueStatus)\n  # plot(newFociRaster)\n  \n  tempFociRaster <- crop(newFociRaster,extent(neighborhood_mask_raster)) \n  \n  # plot(tempFociRaster)\n  \n  localfoci <- as.data.frame(xyFromCell(tempFociRaster,which(tempFociRaster@data@values==1)))   # data frame of local foci\n  nlocalfoci <- nrow(localfoci)              # number of existing new foci in the area\n  \n  if(nlocalfoci>NFOCI) localfoci <- localfoci[sample(c(1:nlocalfoci),NFOCI),]   # if multiple local foci, reduce the number of foci to NFOCI\n  \n  newfocineeded <- max(0,NFOCI-nlocalfoci)  # new foci needed\n  \n  if(newfocineeded>0){\n    \n    candidates <- neighborhood_raster@data@values   # candidates as new foci\n    candidates[candidates>MINABUND] <- 0   # discount cells that are already fairly full  [note, if no cells are below minimum abundace, then another cell will be selected!]\n    candidates[candidates==0] <- 1\n    \n    for(i in 1:newfocineeded){\n      localfoci <- rbind(localfoci,as.data.frame(xyFromCell(tempFociRaster,which.max(candidates))))\n      candidates[which.max(candidates)] <- 0\n    }\n  }\n  \n  allocation <- rmultinom(1,leave,c(1:NFOCI))[,1]\n  localfoci$indiv <- allocation \n  \n  updatedStack <- UpdateAbund(focalxy=xy,stack=newStack,df=localfoci)     # move new individuals to local foci\n  \n  ## update foci\n  ndx <- cellFromXY(newFociRaster,localfoci[,c(1,2)])\n  newFociRaster[ndx] <- 1  \n  \n  assign(x=\"newFociRaster\",value=newFociRaster,envir=.GlobalEnv)\n  # plot(newFociRaster)\n  return(updatedStack)\n}\n\nstayFunction <- function(x,y){\n  #browser()\n  disprate = ifelse(y==1,PLAGUE_DISPERSAL,BASELINE_DISPERSAL)   # NOTE: this creates \"donut holes\" in colonies where plague has been...\n  \n  value <- ifelse(x>MAXABUND,round(MAXABUND*(1-disprate)),round(x*(1-disprate)))\n  value2 <- ifelse(x<MINABUND,0,value)\n  #if(any(!is.na(c))) value[!is.na(c)] <-   #rpois(length(which(!is.na(c))),c[!is.na(c)])\n  return(value2)\n}\n\n####################\n# MAIN DISPERSAL FUNCTION\n####################\n\n#t=which(plagueyear)[1]\ndoDispersal <- function(t=2,PlagueRaster=PlagueRaster){\n\n  ## build up the results fof dispersal\n  newStack <- stack(list(\n    PopArray = reclassify(PopArray,rcl=c(-Inf,Inf,0)),   # blank raster for filling in the dispersal\n    NextPlagueSurvRaster = reclassify(PopArray,rcl=c(-Inf,Inf,0)),   # blank raster for filling in the plague survival\n    NextNormalSurvRaster = reclassify(PopArray,rcl=c(-Inf,Inf,0)),   # blank raster for filling in normal survival\n    PlagueResistancePotentialRaster = reclassify(PopArray,rcl=c(-Inf,Inf,0))  # blank raster for filling in the potential for resistance\n  ))    # raster stack that is updated during the dispersal process...\n  \n  ## determine the cells from which to draw dispersers (cells with positive abundance...)\n    \n  if(t==1) newFociRaster <<- reclassify(PopArray,rcl=c(-Inf,Inf,0))  # store a record of new foci. Last step of dispersal is to spread out these foci... \n  \n  # before doing dispersal, determine who stays in place...\n  stayRaster <- overlay(PopArray,PlagueRaster,fun=stayFunction)\n    # plot(PlagueRaster)\n    # plot(PopArray)\n    # plot(stayRaster)\n  stayRaster[stayRaster<50]\n  \n  leaveRaster <- PopArray-stayRaster   # everyone that didn't stay has to leave!\n  # plot(leaveRaster)\n  \n  #newStack[['PopArray']] <- stayRaster   # update the new poparray with the known stayers. This deals with all \"stay\" individuals so that only leavers must be considered\n  # update the current rasters with the known stayers\n  rasterNames <- rasterNames #names(newStack)\n  n = rasterNames[2]\n  for(n in rasterNames){\n    if(n==\"PopArray\"){\n      newStack[[n]] <- stayRaster\n    }else{\n      newStack[[n]][stayRaster>0] <- eval(parse(text=n))[stayRaster>0]*stayRaster[stayRaster>0]   \n    }\n    # plot(eval(parse(text=n)))\n    # plot(eval(parse(text=n))*stayRaster)\n    # plot(newStack[[n]])\n    # extent <- drawExtent()\n    # plot(crop(stayRaster,extent))   # okay this is actually working\n  }\n \n  focalCells <- which(leaveRaster@data@values>0)   # identify cells with dispersers leaving\n  xy_df <- data.frame(\n    xyFromCell(patchRaster,focalCells)\n  )\n  # reshuffle the order (make foci of expansion a bit more random...)\n  xy_df <- xy_df[sample(c(1:nrow(xy_df))),]\n  \n  # head(xy_df)\n  \n\n  #plot(newStack[[rasterNames[2]]])\n  counter <- 1  \n  focalcell <- focalCells[counter]  # cell from which to draw potential dispersers \n  for(focalcell in focalCells){    # loop through focal cells [actually should only loop through cells that have positive abundance... ]\n    xy <- xy_df[counter,] \n    \n    plagueStatus <- ifelse(PlagueRaster[focalcell]==1,\"plague\",\"noPlague\")   # determine if plague\n    GetDispersalRates(plagueStatus = plagueStatus)  # get the current dispersal rates\n    \n    neighborhoodRasters <- makeNeighborhoodRasters(newStack=newStack,plagueStatus = plagueStatus, xy=xy)  # characterize the possible sites to move to in the neighborhood\n    \n    thisAbund <- as.numeric(PopArray[focalcell])  # abundance in the focal cell\n    \n    overcrowded <- thisAbund>MAXABUND # if overcrowded, then dispersal will unfold in a certain way: e.g., colony will expand outward\n    undercrowded <- thisAbund<MINABUND  # if undercrowded, then dispersal can unfold in a different way: e.g., colony will restructure and group together at new focal areas\n    \n    stay <- stayRaster[focalcell]\n    leave <- leaveRaster[focalcell]\n    \n    if((overcrowded)){   # if focal cell is overcrowded (and not currently experiencing plague)\n      #stay <- stayRaster[focalcell] #MAXABUND*(1-disprate)  # number that should stay\n      #newStack <- UpdateAbund(focalxy=xy,stack=newStack,df=as.data.frame(cbind(xy,stay)))   # keep the \"stay\" individuals in place\n      #leave <- leaveRaster[focalcell] #max(0,thisAbund-MAXABUND) + MAXABUND*disprate \n      #newPop[focalcell] <- newPop[focalcell] + stay   # make sure that all staying individuals stay put... \n      if(plagueStatus==\"plague\") leave_snuggle <- 0  \n      if(plagueStatus==\"noPlague\") leave_snuggle <- floor(leave*SNUGGLE)   # these individuals will try to find a place to settle next door\n      leave_kernel <- leave-leave_snuggle     # these individuals will obey the dispersal kernel\n      \n      # expand the colony\n      newStack <- SpreadOut(newStack=newStack,leave_snuggle=leave_snuggle,\n                            plagueStatus=plagueStatus,xy=xy,neighborhood_raster=neighborhoodRasters[['abundRaster']],\n                            neighborhood_mask_raster=neighborhoodRasters[['maskRaster']],\n                            freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']])\n      \n      # do long-distance dispersal (according to the dispersal kernel)\n      newStack <- LongDistanceDispersal(newStack=newStack,leave_kernel=leave_kernel,\n                                        plagueStatus=plagueStatus,\n                                        xy=xy,\n                                        neighborhood_raster=neighborhoodRasters[['abundRaster']],\n                                        freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']],\n                                        neighborhood_kernel_raster=neighborhoodRasters[['kernelRaster']])\n      \n      \n    }else if((!overcrowded)&(!undercrowded)){   # if focal cell is not overcrowded or undercrowded\n      #stay <- stayRaster[focalcell] #round(thisAbund * (1-BASELINE_DISPERSAL))   # number of individuals staying in the focal cell\n      # newStack <- UpdateAbund(focalxy=xy,stack=newStack,df=as.data.frame(cbind(xy,stay)))   # keep the \"stay\" individuals in place (and update the evolving factors)\n      #leave <- leaveRaster[focalcell] thisAbund-stay  # how many are leaving?\n      \n      # just do long-distance dispersal (according to the dispersal kernel)\n      newStack <- LongDistanceDispersal(newStack=newStack,leave_kernel=leave,\n                                        plagueStatus=plagueStatus,\n                                        xy=xy,\n                                        neighborhood_raster=neighborhoodRasters[['abundRaster']],\n                                        freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']],\n                                        neighborhood_kernel_raster=neighborhoodRasters[['kernelRaster']])\n      \n    }else if((undercrowded)){    # if focal cell is undercrowded\n      \n      #stay <- stayRaster[focalcell] # in this case, all animals leave  (revisit this!)\n      #leave <- stayRaster[focalcell]   #thisAbund\n      \n      # consolidate into new focal populations\n      newStack <- ConsolidatePops(newStack=newStack,leave=leave,\n                                  #newFociRaster=newFociRaster,\n                                  plagueStatus=plagueStatus,\n                                  xy=xy,\n                                  newFociRaster=newFociRaster,\n                                  neighborhood_raster=neighborhoodRasters[['abundRaster']],\n                                  neighborhood_mask_raster=neighborhoodRasters[['maskRaster']])\n      \n      \n    }\n    if(counter%%100==0) cat(sprintf(\"%s...\",counter))\n    counter=counter+1\n  }  # end loop through focal cells\n  \n#   plot(newStack[[\"PopArray\"]])\n#   plot(newFociRaster)\n#   plot(PopArray)\n#   plot(PlagueRaster)\n#   plot(newStack[[rasterNames[2]]])     # plague survival\n  #   plot(newStack[[rasterNames[3]]])\n  \n  ##########\n  # Expand focal cells\n  ##########\n  \n  # plot(newFociRaster)\n  \n  foci_ndx <- which((newFociRaster@data@values==1)&(newStack[[\"PopArray\"]]@data@values>0))\n  totfoci <- length(foci_ndx)\n  # focalcell <- foci_ndx[6]\n  if(totfoci>0){\n    names <- rasterNames   #names(newStack) \n    focalcell = foci_ndx[1]\n    for(focalcell in foci_ndx){  #loop through foci and spread them out!\n      \n      xy <- as.data.frame(xyFromCell(PopArray,focalcell))\n      \n      plagueStatus <- ifelse(PlagueRaster[focalcell]==1,\"plague\",\"noPlague\")   # determine if plague\n      GetDispersalRates(plagueStatus=plagueStatus)  # get the current dispersal rates\n      \n      neighborhoodRasters <- makeNeighborhoodRasters(newStack=newStack,plagueStatus = plagueStatus, xy=xy)  # characterize the possible sites to move to in the neighborhood\n      \n      thisAbund <- as.numeric(newStack[['PopArray']][focalcell])  # abundance in the focal cell\n      \n      # compute the mean values for evolving layers for focal cells so that these values can be spread out\n      i = names[2]\n      for(i in names){\n        if(i!=\"PopArray\"){\n          temp <- newStack[[i]][focalcell]/thisAbund    # get the population mean for key evolving variables\n          eval(parse(text=sprintf(\"%s[focalcell]<-temp\",i)))   # does this need a double arrow when in function? how to assign this to global environment\n          assign(x=i,value=eval(parse(text=i)), envir = .GlobalEnv)   # assign the variable to the global environment\n        }\n      }\n      \n      overcrowded <- thisAbund>MAXABUND # if overcrowded, then dispersal will unfold in a certain way: e.g., colony will expand outward\n      \n      if((overcrowded)){   # if focal cell is overcrowded \n        stay <- MAXABUND-thisAbund  # number that should stay (here, negative so that individuals are removed)\n        newStack <- UpdateAbund(focalxy=xy,stack=newStack,df=as.data.frame(cbind(xy,stay)))   # keep the \"stay\" individuals in place\n        leave <- max(0,thisAbund-MAXABUND)  \n        \n        # expand the colony\n        newStack <- SpreadOut(newStack=newStack,leave_snuggle=leave,\n                              plagueStatus=plagueStatus,xy=xy,neighborhood_raster=neighborhoodRasters[['abundRaster']],\n                              neighborhood_mask_raster=neighborhoodRasters[['maskRaster']],\n                              freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']])\n      }\n    }\n  }\n  \n  UpdateStack(stack=newStack)   # make the new population, get the averages for the evolving layers and save them to .GlobalEnv\n  \n  newPop <- newStack[['PopArray']]\n  #  PopArray <- newStack[['PopArray']]\n  return(newPop)\n}\n\n##################\n# FECUNDITY FUNCTIONS\n##################\n\n# c=c(1,2,3,4,NA,5)\ndemographicStoch <- function(c){\n  value=c\n  if(any(!is.na(c))) value[!is.na(c)] <- rpois(length(which(!is.na(c))),c[!is.na(c)])    # why does this throw errors sometimes?\n  return(value)\n}\n\ndoReproduce <- function(PlagueRaster=PlagueRaster){\n  thisPop <- PopArray\n  #thisFec <- rnorm(1,BASELINE_MEANFEC,CV_FECUNDITY*BASELINE_MEANFEC)\n  thisFec <- BASELINE_MEANFEC + (CV_FECUNDITY*BASELINE_MEANFEC)*deviate\n  thisFec <- max(0.1,thisFec)  # make sure fecundity is not zero\n  #thisPop[(thisPop<MINABUND)] <- 0  # populations below the allee threshold cannot breed\n  thisPop[(PlagueRaster==0)&(thisPop>MINABUND)] <- thisPop[(PlagueRaster==0)&(thisPop>MINABUND)] + PopArray[(PlagueRaster==0)&(thisPop>MINABUND)]*thisFec\n  thisPop[(PlagueRaster==1)&(thisPop>MINABUND)] <- thisPop[(PlagueRaster==1)&(thisPop>MINABUND)] + (PopArray[(PlagueRaster==1)&(thisPop>MINABUND)]*thisFec)/2   # reduced fecundity under plague...\n  thisPop <- calc(thisPop,fun=demographicStoch)\n  # plot(thisPop)\n  return(thisPop)\n}\n\n##################\n# SURVIVAL FUNCTIONS\n##################\n\n#a=c(NA,NA,0.5,0.7)\n#a=c(NA,NA,NA)\n# a = c(NA,NA,NA,NA,NA)\ngetYearVariate <- function(a){            # note: this function could work for fecundity too...\n  #browser()\n  sd <- a*cv\n  value <- rep(NA,times=length(a))\n  if(any(!is.na(sd))){ \n    value[!is.na(sd)] <- a[!is.na(sd)] + deviate*sd[!is.na(sd)]    # for now, spatially correlated... \n    value[value<SURVMIN_NOPLAGUE] <- SURVMIN_NOPLAGUE\n    value[value>SURVMAX_NOPLAGUE] <- SURVMAX_NOPLAGUE\n  }\n  return(value)\n}\n\n\ngetSurvival <- function(resistanceStatus=\"susceptible\",plagueStatus=\"plague\"){\n  if((plagueStatus==\"noPlague\")&(resistanceStatus==\"susceptible\")) survival = BASELINE_MEANSURV\n  if((plagueStatus==\"noPlague\")&(resistanceStatus==\"resistant\")) survival = BASELINE_MEANSURV - FITNESS_COST*(BASELINE_MEANSURV*BASELINE_PLAGUESURV_RESIST-SURVMIN_PLAGUE)\n  if((plagueStatus==\"plague\")&(resistanceStatus==\"susceptible\")) survival = BASELINE_PLAGUESURV\n  if((plagueStatus==\"plague\")&(resistanceStatus==\"resistant\")) survival = BASELINE_MEANSURV*BASELINE_PLAGUESURV_RESIST\n  return(survival)\n}\n\ngetSurvival_thisYear <- function(meansurv=meansurv,deviate=deviate,cv=cv){\n  surv <- meansurv + deviate*(surv*cv)\n  surv[,\"plague\"] <- min(SURVMAX_PLAGUE,max(SURVMIN_PLAGUE,surv[\"resistant\",\"plague\"]))\n  surv[,\"noPlague\"] <- min(SURVMAX_NOPLAGUE,max(SURVMIN_NOPLAGUE,surv[\"resistant\",\"plague\"]))  \n  return(surv)\n}\n\ndoSurvival <- function(PopArray=PopArray,PlagueRaster=PlagueRaster){\n  #thisPop <- getValues(PopArray)\n  thisPop <- PopArray\n  \n  surv <- getSurvival_thisYear(meansurv,deviate,cv)\n  \n  for(status in c(\"resistant\",\"susceptible\")){\n    thisPop[[status]][PlagueRaster==1] <- thisPop[[status]][PlagueRaster==1]*surv[status,\"plague\"]\n    thisPop[[status]][PlagueRaster==0] <- thisPop[[status]][PlagueRaster==0]*surv[status,\"noPlague\"]\n  }\n  \n  # thisSurvRaster <- calc(NextNormalSurvRaster,fun=getYearVariate)     # first compute \"normal\" survival\n  # thisSurvRaster[PlagueRaster==1] <- NextPlagueSurvRaster[PlagueRaster==1]     #account for plague mortality\n  # \n  # #plot(PopArray)\n  # #plot(thisSurvRaster)\n  # # plot(NextNormalSurvRaster)\n  # #if(plagueyear[t]){\n  # \n  # thisPop <- thisPop*thisSurvRaster    # account for survival this year\n  # # plot(thisSurvRaster)\n  # # plot(thisPop)\n  # ###################\n  # # accout for change in fitness due to selection\n  #    #NextPlagueSurvRaster <- NextPlagueSurvRaster * thisPop\n  # NextPlagueSurvRaster[(PlagueRaster==1)&(thisPop>0)] <- NextPlagueSurvRaster[(PlagueRaster==1)&(thisPop>0)] + \n  #   PlagueResistancePotentialRaster[(PlagueRaster==1)&(thisPop>0)]              # account for development of plague resistance during plague\n  # NextPlagueSurvRaster[NextPlagueSurvRaster>SURVMAX_PLAGUE] <- SURVMAX_PLAGUE\n  # \n  # #  plot(NextPlagueSurvRaster) \n  # \n  # ###################\n  # # account for fitness costs due to selection\n  # NextNormalSurvRaster[(PlagueRaster==1)&(thisPop>0)] <- NextNormalSurvRaster[(PlagueRaster==1)&(thisPop>0)] - \n  #   PlagueResistancePotentialRaster[(PlagueRaster==1)&(thisPop>0)] * FITNESS_COST     # account for fitness cost during plague\n  # NextNormalSurvRaster[NextNormalSurvRaster<SURVMIN_NOPLAGUE] <- SURVMIN_NOPLAGUE\n  # \n  # #  plot(NextNormalSurvRaster) \n  # \n  # NextPlagueSurvRaster[(PlagueRaster==0)&(thisPop>0)] <- NextPlagueSurvRaster[(PlagueRaster==0)&(thisPop>0)] - \n  #   PlagueResistancePotentialRaster[(PlagueRaster==0)&(thisPop>0)] * FITNESS_COST   # account for fitness cost during no plague \n  # NextPlagueSurvRaster[NextPlagueSurvRaster<SURVMIN_PLAGUE] <- SURVMIN_PLAGUE\n  # \n  # #  plot(NextPlagueSurvRaster) \n  # # account for fitness costs due to selection\n  # NextNormalSurvRaster[(PlagueRaster==0)&(thisPop>0)] <- NextNormalSurvRaster[(PlagueRaster==0)&(thisPop>0)] + \n  #   PlagueResistancePotentialRaster[(PlagueRaster==0)&(thisPop>0)] * FITNESS_COST     # account for loss of resistance during no plague\n  # NextNormalSurvRaster[NextNormalSurvRaster>SURVMAX_NOPLAGUE] <- SURVMAX_NOPLAGUE\n  # \n  # \n  # #plot(NextNormalSurvRaster)\n  # # }else{\n  # #   thisPop <- thisPop*thisSurvRaster   # no demographic stochasticity here... \n  # #   #plot(thisPop)\n  # # }\n  # \n  # i=rasterNames[2]\n  # for(i in rasterNames){\n  #   if(i!=\"PopArray\")\n  #   assign(i,eval(parse(text=i)),envir = .GlobalEnv)\n  # }\n  # \n  return(thisPop)\n}\n\n##################\n# DD SURVIVAL FUNCTION\n##################\n\ndoDDSurvival <- function(){\n  \n  thisPop <- PopArray\n  for(status in c(\"resistant\",\"susceptible\")){\n    thisPop[[status]][PopArray>(MAXABUND*1.15)] <- MAXABUND*1.15  # kill off all individuals in populations above the threshold\n  }\n  return(thisPop)\n  \n}\n\n\n##################\n# ALLEE FUNCTION\n##################\n\ndoAllee <- function(){\n  \n  thisPop <- PopArray\n  thisPop[PopArray<MINABUND] <- 0  # kill off all individuals in populations below the threshold\n  return(thisPop)\n  \n}\n\n\n",
    "created" : 1472506174631.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3241086287",
    "id" : "7CC3B03D",
    "lastKnownWriteTime" : 1472513813,
    "last_content_update" : 1472513813669,
    "path" : "E:/GIT/Plague_Resistance_Evolution/PlagueResistanceEvolution_FUNCTIONS.R",
    "project_path" : "PlagueResistanceEvolution_FUNCTIONS.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}