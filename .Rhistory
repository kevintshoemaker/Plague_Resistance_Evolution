fakedens <- seq(0,200,length=faken)
fakeplaguepops <- sample(c(0:15),faken,replace=T)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
fakeplagueprob
GetPlagueModel <- function(){
BETADENS <- 0.0005
BETAPLAGUE <- 0.05
INTERACTION <- 0.03
INTERCEPT <- -9
faken <- 1000
fakedens <- seq(0,200,length=faken)
fakeplaguepops <- sample(c(0:15),faken,replace=T)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
# raster::plot(fakeplagueprob~fakeplaguepops)
#raster::plot(fakeplagueprob~fakedens)
fakeplague <- rbinom(faken,1,fakeplagueprob)
dataFrame <- data.frame(plague=fakeplague,dens=fakedens,plaguepops=fakeplaguepops)
plaguemodel <- glm(plague~1+plaguepops*dens,data=dataFrame,family="binomial")
plogis(predict(plaguemodel,newdata=data.frame(dens=c(10:10),plaguepops=c(1:10))))
#summary(plaguemodel)
return(plaguemodel)
}
# 8/29/16: changed to consider a binary resistance trait that is potentially a function of several gene loci...
############
## CLEAR WORKSPACE
############
rm(list=ls())
############
## SIMULATION CONTROLS
############
NYEARS <- 50
100%%5
101%%5
120/5
# time step is one year
# consider scalar demographic model for now, but with potential for matrix model
# 8/29/16: changed to consider a binary resistance trait that is potentially a function of several gene loci...
############
## CLEAR WORKSPACE
############
rm(list=ls())
############
## SIMULATION CONTROLS
############
NYEARS <- 50
############
## SET GLOBAL VARS
############
KEVIN_LAPTOP <- TRUE #  FALSE #
KEVIN_OFFICEPC <- FALSE # TRUE #
if(KEVIN_LAPTOP) GIT_DIR <- "C:\\Users\\Kevin\\GIT\\Plague_Resistance_Evolution"
if(KEVIN_OFFICEPC) GIT_DIR <- "E:\\GIT\\Plague_Resistance_Evolution"
#####################
# LOAD FUNCTIONS
#####################
setwd(GIT_DIR)
source("PlagueResistanceEvolution_FUNCTIONS.R")
############
## SET UP WORKSPACE AND LOAD PACKAGES
############
dirs <- SetUpDirectories()
num_cores <- parallel::detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
############
## SAMPLE FROM LATIN HYPERCUBE
############
N_LHS_SAMPLES <- 120
masterDF <- MakeLHSSamples(nicheBreadthDir=dir,NicheBreadth)
###########
##  START A PARALLEL FOR LOOP
###########
library(parallel)
library(doParallel)
cl <- parallel::makeCluster(num_cores,outfile="LOG.TXT")
doParallel::registerDoParallel(cl=cl)    # make the cluster
#######################
## objects to export to each node in the cluster
# functionlist <- c()   # , 'mp.write'
# filelist <- c()  # 'masterDF', 'MP_DIRECTORY','template','GENTIME','humanArrival.df','EXE_DIRECTORY','DLL_FILENAME','dispersalFunc.df','DistClasses','NPOPS','DistBins',
#
# objectlist <- c(functionlist,filelist)   # full list of objects to export
#
#
# packagelist <- c("secr","igraph","raster")
allsamples <- foreach(i = 61: (60+nrow(masterDF))
# .export=objectlist,
# .packages = packagelist,
# .errorhandling=c("pass")
) %dopar% {
# #####################
# # LOAD FUNCTIONS
# #####################
#
# setwd(GIT_DIR)
# source("PlagueResistanceEvolution_FUNCTIONS.R")
#
############
## SET UP WORKSPACE AND LOAD PACKAGES
############
#SetUpWorkspace()
#num_cores <- detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
temp <- MakeWorker(NYEARS, masterDF, dirs)(i)  #DoSimulateResistance(rep=i)    # simulate for these params...
}     ## end parallel for loop
BETADENS <- 0.005  # 0.005
BETAPLAGUE <- 0.9  # 0.9
INTERACTION <- 0.03
INTERCEPT <- -6  # -6
faken <- 1000
fakedens <- seq(0,200,length=faken)
fakeplaguepops <- sample(c(0:15),faken,replace=T)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
fakeplagueprob
BETADENS <- 0.001  # 0.005
BETAPLAGUE <- 0.9  # 0.9
INTERACTION <- 0.05  # 0.03
INTERCEPT <- -6  # -6
faken <- 1000
fakedens <- seq(0,200,length=faken)
fakeplaguepops <- sample(c(0:15),faken,replace=T)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
fakeplagueprob
faken <- 1000
fakedens <- seq(0,200,length=faken)
fakeplaguepops <- sample(c(0:5),faken,replace=T)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
fakeplagueprob
# time step is one year
# consider scalar demographic model for now, but with potential for matrix model
# 8/29/16: changed to consider a binary resistance trait that is potentially a function of several gene loci...
############
## CLEAR WORKSPACE
############
rm(list=ls())
############
## SIMULATION CONTROLS
############
NYEARS <- 50
############
## SET GLOBAL VARS
############
KEVIN_LAPTOP <- TRUE #  FALSE #
KEVIN_OFFICEPC <- FALSE # TRUE #
if(KEVIN_LAPTOP) GIT_DIR <- "C:\\Users\\Kevin\\GIT\\Plague_Resistance_Evolution"
if(KEVIN_OFFICEPC) GIT_DIR <- "E:\\GIT\\Plague_Resistance_Evolution"
#####################
# LOAD FUNCTIONS
#####################
setwd(GIT_DIR)
source("PlagueResistanceEvolution_FUNCTIONS.R")
############
## SET UP WORKSPACE AND LOAD PACKAGES
############
dirs <- SetUpDirectories()
num_cores <- parallel::detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
############
## SAMPLE FROM LATIN HYPERCUBE
############
N_LHS_SAMPLES <- 120
masterDF <- MakeLHSSamples(nicheBreadthDir=dir,NicheBreadth)
###########
##  START A PARALLEL FOR LOOP
###########
library(parallel)
library(doParallel)
cl <- parallel::makeCluster(num_cores,outfile="LOG.TXT")
doParallel::registerDoParallel(cl=cl)    # make the cluster
#######################
## objects to export to each node in the cluster
# functionlist <- c()   # , 'mp.write'
# filelist <- c()  # 'masterDF', 'MP_DIRECTORY','template','GENTIME','humanArrival.df','EXE_DIRECTORY','DLL_FILENAME','dispersalFunc.df','DistClasses','NPOPS','DistBins',
#
# objectlist <- c(functionlist,filelist)   # full list of objects to export
#
#
# packagelist <- c("secr","igraph","raster")
allsamples <- foreach(i = 61: (60+nrow(masterDF))
# .export=objectlist,
# .packages = packagelist,
# .errorhandling=c("pass")
) %dopar% {
# #####################
# # LOAD FUNCTIONS
# #####################
#
# setwd(GIT_DIR)
# source("PlagueResistanceEvolution_FUNCTIONS.R")
#
############
## SET UP WORKSPACE AND LOAD PACKAGES
############
#SetUpWorkspace()
#num_cores <- detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
temp <- MakeWorker(NYEARS, masterDF, dirs)(i)  #DoSimulateResistance(rep=i)    # simulate for these params...
}     ## end parallel for loop
#MakeWorker(NYEARS, masterDF, dirs)(1)
###################
# CLOSE CLUSTER
###################
if(!is.null(cl)) {
parallel::stopCluster(cl)
cl <- c()
}
BETADENS <- 0.001  # 0.005
BETAPLAGUE <- 0.9  # 0.9
INTERACTION <- 0.05  # 0.03
INTERCEPT <- -6  # -6
faken <- 1000
fakedens <- seq(0,200,length=faken)
fakeplaguepops <- sample(c(0:5),faken,replace=T)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
fakeplagueprob
fakedens
fakeplaguepops
fakeplagueprob
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens)
fakeplagueprob
BETADENS <- 0.01  # 0.005
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens)
fakeplagueprob
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops)
fakeplagueprob
BETAPLAGUE <- 0.1
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops)
fakeplagueprob
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
fakeplagueprob
fakeplaguepops <- rep(c(0:5),times = 200)
fakeplaguepops
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
fakedens
fakeplaguepops <- rep(c(0:4),times = 200)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops)
fakeplaguepops
fakeplagueprob
BETAPLAGUE
seq(0,200,by=50)
rep(seq(0,200,by=50),each=10)
length(rep(seq(0,200,by=50),each=10))
fakedens <- rep(seq(0,200,by=50),each=10)
fakeplaguepops <- rep(c(0:4),times = 10)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
fakeplagueprob
matrix(fakeplagueprob,ncol=5)
fakedens
fakeplaguepops
BETADENS
BETADENS <- 0.05  # 0.005
fakedens <- rep(seq(0,200,by=50),each=10)
fakeplaguepops <- rep(c(0:4),times = 10)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
matrix(fakeplagueprob,ncol=5)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops)
matrix(fakeplagueprob,ncol=5)
BETAPLAGUE <- 0.01  # 0.9
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops)
matrix(fakeplagueprob,ncol=5)
matrix(fakeplagueprob,ncol=5,byrow=T)
fakeplagueprob
fakedens
fakeplaguepops
fakedens <- rep(seq(0,200,by=50),each=10)
fakedens
fakeplaguepops <- rep(c(0:9),times = 5)
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
matrix(fakeplagueprob,ncol=10,byrow=T)
fakedens
fakeplaguepops
BETADENS <- 0.05  # 0.005
BETAPLAGUE <- 0.01  # 0.9
INTERACTION <- 0.05  # 0.03
INTERCEPT <- -6
BETADENS <- 0.005  # 0.005
BETAPLAGUE <- 0.9  # 0.9
INTERACTION <- 0.03  # 0.03
INTERCEPT <- -6
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
matrix(fakeplagueprob,ncol=10,byrow=T)
BETADENS <- 0.05  # 0.005
BETAPLAGUE <- 0.01  # 0.9
INTERACTION <- 0.05  # 0.03
INTERCEPT <- -6  # -6
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
matrix(fakeplagueprob,ncol=10,byrow=T)
BETADENS <- 0.02  # 0.005
BETAPLAGUE <- 0.01  # 0.9
INTERACTION <- 0.05  # 0.03
INTERCEPT <- -6  # -6
fakeplagueprob <- plogis(INTERCEPT + BETADENS*fakedens + BETAPLAGUE*fakeplaguepops + INTERACTION*fakeplaguepops*fakedens)
matrix(fakeplagueprob,ncol=10,byrow=T)
KEVIN_LAPTOP <- FALSE #  TRUE #
KEVIN_OFFICEPC <- TRUE # FALSE #
rm(list=ls())
rm(list=ls())
############
## SIMULATION CONTROLS
############
NYEARS <- 50
############
## SET GLOBAL VARS
############
KEVIN_LAPTOP <- FALSE #  TRUE #
KEVIN_OFFICEPC <- TRUE # FALSE #
if(KEVIN_LAPTOP) GIT_DIR <- "C:\\Users\\Kevin\\GIT\\Plague_Resistance_Evolution"
if(KEVIN_OFFICEPC) GIT_DIR <- "E:\\GIT\\Plague_Resistance_Evolution"
setwd(GIT_DIR)
source("PlagueResistanceEvolution_FUNCTIONS.R")
dirs <- SetUpDirectories()
num_cores <- parallel::detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
num_cores
parallel::detectCores()
num_cores <- parallel::detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
N_LHS_SAMPLES <- 120
num_cores
# time step is one year
# consider scalar demographic model for now, but with potential for matrix model
# 8/29/16: changed to consider a binary resistance trait that is potentially a function of several gene loci...
############
## CLEAR WORKSPACE
############
rm(list=ls())
############
## SIMULATION CONTROLS
############
NYEARS <- 50
############
## SET GLOBAL VARS
############
KEVIN_LAPTOP <- FALSE #  TRUE #
KEVIN_OFFICEPC <- TRUE # FALSE #
if(KEVIN_LAPTOP) GIT_DIR <- "C:\\Users\\Kevin\\GIT\\Plague_Resistance_Evolution"
if(KEVIN_OFFICEPC) GIT_DIR <- "E:\\GIT\\Plague_Resistance_Evolution"
#####################
# LOAD FUNCTIONS
#####################
setwd(GIT_DIR)
source("PlagueResistanceEvolution_FUNCTIONS.R")
############
## SET UP WORKSPACE AND LOAD PACKAGES
############
dirs <- SetUpDirectories()
num_cores <- parallel::detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
############
## SAMPLE FROM LATIN HYPERCUBE
############
N_LHS_SAMPLES <- 150
masterDF <- MakeLHSSamples(nicheBreadthDir=dir,NicheBreadth)
masterDF
library(parallel)
library(doParallel)
cl <- parallel::makeCluster(num_cores,outfile="LOG.TXT")
doParallel::registerDoParallel(cl=cl)    # make the cluster
allsamples <- foreach(i = 1:nrow(masterDF))
# .export=objectlist,
# .packages = packagelist,
# .errorhandling=c("pass")
) %dopar% {
# #####################
# # LOAD FUNCTIONS
# #####################
#
# setwd(GIT_DIR)
# source("PlagueResistanceEvolution_FUNCTIONS.R")
#
############
## SET UP WORKSPACE AND LOAD PACKAGES
############
#SetUpWorkspace()
#num_cores <- detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
temp <- MakeWorker(NYEARS, masterDF, dirs)(i)  #DoSimulateResistance(rep=i)    # simulate for these params...
}     ## end parallel for loop
#MakeWorker(NYEARS, masterDF, dirs)(1)
###################
# CLOSE CLUSTER
###################
if(!is.null(cl)) {
parallel::stopCluster(cl)
cl <- c()
}
N_LHS_SAMPLES <- 150
dirs <- SetUpDirectories()
num_cores <- parallel::detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
############
## SAMPLE FROM LATIN HYPERCUBE
############
N_LHS_SAMPLES <- 150
masterDF <- MakeLHSSamples(nicheBreadthDir=dir,NicheBreadth)
###########
##  START A PARALLEL FOR LOOP
###########
library(parallel)
library(doParallel)
cl <- parallel::makeCluster(num_cores,outfile="LOG.TXT")
doParallel::registerDoParallel(cl=cl)    # make the cluster
allsamples <- foreach(i = 1: (0+nrow(masterDF))
# .export=objectlist,
# .packages = packagelist,
# .errorhandling=c("pass")
) %dopar% {
# #####################
# # LOAD FUNCTIONS
# #####################
#
# setwd(GIT_DIR)
# source("PlagueResistanceEvolution_FUNCTIONS.R")
#
############
## SET UP WORKSPACE AND LOAD PACKAGES
############
#SetUpWorkspace()
#num_cores <- detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
temp <- MakeWorker(NYEARS, masterDF, dirs)(i)  #DoSimulateResistance(rep=i)    # simulate for these params...
}     ## end parallel for loop
#MakeWorker(NYEARS, masterDF, dirs)(1)
###################
# CLOSE CLUSTER
###################
if(!is.null(cl)) {
parallel::stopCluster(cl)
cl <- c()
}
i
1683/200
30/4
RF_UnivariatePlots(object=rf_model1, varimp=model1_importance, data=df,  #
predictors=pred.names[9], labels=predictorNames[9], allpredictors=pred.names,plot.layout=c(1,1))
masterDF
read.csv("masterDF_prelim2017-01-26.csv",header=T)
setwd(dirs$DATA_DIR)
read.csv("masterDF_prelim2017-01-26.csv",header=T)
masterDF <- read.csv("masterDF_prelim2017-01-26.csv",header=T)
setwd(GIT_DIR)
source("PlagueResistanceEvolution_FUNCTIONS.R")
dirs <- SetUpDirectories()
num_cores <- parallel::detectCores() - 2   # for setting up cluster... leave one core free for windows background processes?
setwd(dirs$DATA_DIR)
masterDF <- read.csv("masterDF_prelim2017-01-26.csv",header=T)
masterDF2 <- HarvestData(masterDF,dirs)
masterDF2$ISRES <- as.factor(masterDF2$ISRES)
masterDF2$ISEXT <- as.factor(masterDF2$ISEXT)
masterDF2$DOMINANCE <- as.factor(masterDF2$DOMINANCE)
df <- na.omit(masterDF2)
predictorNames <- c(  "% Habitat",       # nice readable names
"Conspecific attraction",
"Plague colony disruption",
"Maximum density per ha",
"Plague survival, susceptible",
"Mean fecundity",
"Fitness cost of resistance",
"Initial resistance allele freq.",
"Dominance of resistance factors"
)
pred.names=c(  "PER_SUITABLE",
"SNUGGLE",
"PLAGUE_DISPERSAL",
"MAXDENS",
"BASELINE_PLAGUESURV",
"BASELINE_MEANFEC",
"FITNESS_COST",
"INITFREQ",
"DOMINANCE"
)
cbind(pred.names,predictorNames)
cbind(pred.names,predictorNames)
response=  "ISEXT"   #  "ISRES"    #
formula1 <- as.formula(paste(response,"~",paste(pred.names,collapse="+")))
source_github("https://raw.githubusercontent.com/kevintshoemaker/Random-Forest-Functions/master/","RF_Extensions.R")
res.tr <- ctree(formula=formula1, data=df, controls = ctree_control(mincriterion = 0.6,maxdepth = 3))
plot(res.tr)
summary(res.tr)
cforestControl <- cforest_unbiased(ntree=1000,mtry=3)   # change back to 500!!
cforestControl@fraction <- 0.75
cforestControl@gtctrl@mincriterion <- 0.5
rf_model1 <- cforest(formula1, controls=cforestControl, data=df)
cforestControl <- cforest_unbiased(ntree=1000,mtry=5)   # change back to 500!!
cforestControl@fraction <- 0.75
cforestControl@gtctrl@mincriterion <- 0.5
rf_model1 <- cforest(formula1, controls=cforestControl, data=df)
model1_importance<-varimp((rf_model1), conditional= FALSE)
graphics.off()
lengthndx <- length(model1_importance)
#par(mai=c(0.95,3.1,0.6,0.4))
par(mai=c(1.4,3.4,0.6,0.9))
col <- rainbow(lengthndx, start = 3/6, end = 4/6)      # rep(brewer.pal(6,"Blues"),each=2)
barplot(height=model1_importance[order(model1_importance,decreasing = FALSE)],
horiz=T,las=1,main="Order of Importance of Predictor Variables",
xlab="Index of overall importance",col=col,
names.arg=predictorNames[match(names(model1_importance),pred.names)][order(model1_importance,decreasing = FALSE)])
RF_UnivariatePlots(object=rf_model1, varimp=model1_importance, data=df,  #
predictors=pred.names[1], labels=predictorNames[1], allpredictors=pred.names,plot.layout=c(1,1))
RF_UnivariatePlots(object=rf_model1, varimp=model1_importance, data=df,  #
predictors=pred.names[9], labels=predictorNames[9], allpredictors=pred.names,plot.layout=c(1,1))
model1_importance
graphics.off()
lengthndx <- length(model1_importance)
#par(mai=c(0.95,3.1,0.6,0.4))
par(mai=c(1.4,3.4,0.6,0.9))
col <- rainbow(lengthndx, start = 3/6, end = 4/6)      # rep(brewer.pal(6,"Blues"),each=2)
barplot(height=model1_importance[order(model1_importance,decreasing = FALSE)],
horiz=T,las=1,main="Order of Importance of Predictor Variables",
xlab="Index of overall importance",col=col,
names.arg=predictorNames[match(names(model1_importance),pred.names)][order(model1_importance,decreasing = FALSE)])
pred.names
RF_UnivariatePlots(object=rf_model1, varimp=model1_importance, data=df,  #
predictors=pred.names[3], labels=predictorNames[3], allpredictors=pred.names,plot.layout=c(1,1))
RF_UnivariatePlots(object=rf_model1, varimp=model1_importance, data=df,  #
predictors=pred.names[7], labels=predictorNames[7], allpredictors=pred.names,plot.layout=c(1,1))
res.tr <- ctree(formula=formula1, data=df, controls = ctree_control(mincriterion = 0.6,maxdepth = 3))
plot(res.tr)
187.04*2
187.04*6
187.04*9
10000/4
