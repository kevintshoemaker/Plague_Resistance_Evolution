counter <- 1
focalcell <- focalCells[counter]
xy <- xy_df[counter,]
plagueStatus <- ifelse(PlagueRaster[focalcell]==1,"plague","noPlague")   # determine if plague
GetDispersalRates(plagueStatus = plagueStatus,UserParams,env)  # get the current dispersal rates
neighborhoodRasters <- makeNeighborhoodRasters(newStack,plagueStatus = plagueStatus, xy=xy,UserParams,env)  # characterize the possible sites to move to in the neighborhood
thisAbund <- as.numeric(DensRaster[focalcell])  # abundance in the focal cell
thisAbund <- as.numeric(DensRaster[focalcell])  # abundance in the focal cell
overcrowded <- thisAbund>UserParams$Popbio$MAXABUND # if overcrowded, then dispersal will unfold in a certain way: e.g., colony will expand outward
undercrowded <- thisAbund<UserParams$Popbio$MINABUND  # if undercrowded, then dispersal can unfold in a different way: e.g., colony will restructure and group together at new focal areas
stay <- stayRaster[focalcell]
leave <- leaveRaster[focalcell]
overcrowded
if(plagueStatus=="plague") leave_snuggle <- 0
if(plagueStatus=="noPlague") leave_snuggle <- floor(leave*UserParams$Dispersal$SNUGGLE)   # these individuals will try to find a place to settle next door
leave_kernel <- leave-leave_snuggle     # these individuals will obey the dispersal kernel
newStack <- SpreadOut(newStack=newStack,leave_snuggle=leave_snuggle,
plagueStatus=plagueStatus,xy=xy,neighborhood_raster=neighborhoodRasters[['abundRaster']],
neighborhood_mask_raster=neighborhoodRasters[['maskRaster']],
freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']],UserParams,env)
newStack <- LongDistanceDispersal(newStack=newStack,leave_kernel=leave_kernel,
plagueStatus=plagueStatus,
xy=xy,
neighborhood_raster=neighborhoodRasters[['abundRaster']],
freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']],
neighborhood_kernel_raster=neighborhoodRasters[['kernelRaster']],
UserParams,env)
newStack <- LongDistanceDispersal(newStack=newStack,leave_kernel=leave_kernel,
plagueStatus=plagueStatus,
xy=xy,
neighborhood_raster=neighborhoodRasters[['abundRaster']],
freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']],
neighborhood_kernel_raster=neighborhoodRasters[['kernelRaster']],
UserParams,env)
foci_ndx <- which((newFociRaster@data@values==1)&(newStack[["DensRaster"]]@data@values>0))
totfoci <- length(foci_ndx)
if(totfoci>0){
names <- paste("gene",1:UserParams$Genetics$NGENES,sep="")
focalcell = foci_ndx[1]
for(focalcell in foci_ndx){  #loop through foci and spread them out!
xy <- as.data.frame(xyFromCell(DensRaster,focalcell))
plagueStatus <- ifelse(PlagueRaster[focalcell]==1,"plague","noPlague")   # determine if plague
GetDispersalRates(plagueStatus=plagueStatus,UserParams,env)  # get the current dispersal rates
neighborhoodRasters <- makeNeighborhoodRasters(newStack=newStack,plagueStatus = plagueStatus, xy=xy,UserParams,env)  # characterize the possible sites to move to in the neighborhood
thisAbund <- as.numeric(newStack[['DensRaster']][focalcell])  # abundance in the focal cell
# compute the mean values for evolving layers for focal cells so that these values can be spread out
i = names[2]
for(i in names){
if(i!="DensRaster"){
temp <- newStack[[i]][focalcell]/thisAbund    # get the population mean for key evolving variables
eval(parse(text=sprintf("FreqList[[\"%s\"]][focalcell]<-temp",i)))   # does this need a double arrow when in function? how to assign this to global environment
#assign(x=i,value=eval(parse(text=i)), envir = env)   # assign the variable to the global environment
}
}
assign(x="FreqList",value=eval(parse(text="FreqList")), envir = env)   # assign the variable to the global environment
overcrowded <- thisAbund>UserParams$Popbio$MAXABUND # if overcrowded, then dispersal will unfold in a certain way: e.g., colony will expand outward
if((overcrowded)){   # if focal cell is overcrowded
stay <- UserParams$Popbio$MAXDENS_HA-thisAbund  # number that should stay (here, negative so that individuals are removed)
newStack <- UpdateAbund(focalxy=xy,stack=newStack,df=as.data.frame(cbind(xy,stay)))   # keep the "stay" individuals in place
leave <- max(0,thisAbund-UserParams$Popbio$MAXABUND)
# expand the colony
newStack <- SpreadOut(newStack=newStack,leave_snuggle=leave,
plagueStatus=plagueStatus,xy=xy,neighborhood_raster=neighborhoodRasters[['abundRaster']],
neighborhood_mask_raster=neighborhoodRasters[['maskRaster']],
freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']],UserParams,env)
}
}
for(focalcell in foci_ndx){  #loop through foci and spread them out!
xy <- as.data.frame(xyFromCell(DensRaster,focalcell))
plagueStatus <- ifelse(PlagueRaster[focalcell]==1,"plague","noPlague")   # determine if plague
GetDispersalRates(plagueStatus=plagueStatus,UserParams,env)  # get the current dispersal rates
neighborhoodRasters <- makeNeighborhoodRasters(newStack=newStack,plagueStatus = plagueStatus, xy=xy,UserParams,env)  # characterize the possible sites to move to in the neighborhood
thisAbund <- as.numeric(newStack[['DensRaster']][focalcell])  # abundance in the focal cell
# compute the mean values for evolving layers for focal cells so that these values can be spread out
i = names[2]
for(i in names){
if(i!="DensRaster"){
temp <- newStack[[i]][focalcell]/thisAbund    # get the population mean for key evolving variables
eval(parse(text=sprintf("FreqList[[\"%s\"]][focalcell]<-temp",i)))   # does this need a double arrow when in function? how to assign this to global environment
#assign(x=i,value=eval(parse(text=i)), envir = env)   # assign the variable to the global environment
}
}
assign(x="FreqList",value=eval(parse(text="FreqList")), envir = env)   # assign the variable to the global environment
overcrowded <- thisAbund>UserParams$Popbio$MAXABUND # if overcrowded, then dispersal will unfold in a certain way: e.g., colony will expand outward
if((overcrowded)){   # if focal cell is overcrowded
stay <- UserParams$Popbio$MAXDENS_HA-thisAbund  # number that should stay (here, negative so that individuals are removed)
newStack <- UpdateAbund(focalxy=xy,stack=newStack,df=as.data.frame(cbind(xy,stay)))   # keep the "stay" individuals in place
leave <- max(0,thisAbund-UserParams$Popbio$MAXABUND)
# expand the colony
newStack <- SpreadOut(newStack=newStack,leave_snuggle=leave,
plagueStatus=plagueStatus,xy=xy,neighborhood_raster=neighborhoodRasters[['abundRaster']],
neighborhood_mask_raster=neighborhoodRasters[['maskRaster']],
freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']],UserParams,env)
}
}
if(totfoci>0){
names <- paste("gene",1:UserParams$Genetics$NGENES,sep="")
focalcell = foci_ndx[1]
for(focalcell in foci_ndx){  #loop through foci and spread them out!
xy <- as.data.frame(xyFromCell(DensRaster,focalcell))
plagueStatus <- ifelse(PlagueRaster[focalcell]==1,"plague","noPlague")   # determine if plague
GetDispersalRates(plagueStatus=plagueStatus,UserParams,env)  # get the current dispersal rates
neighborhoodRasters <- makeNeighborhoodRasters(newStack=newStack,plagueStatus = plagueStatus, xy=xy,UserParams,env)  # characterize the possible sites to move to in the neighborhood
thisAbund <- as.numeric(newStack[['DensRaster']][focalcell])  # abundance in the focal cell
# compute the mean values for evolving layers for focal cells so that these values can be spread out
i = names[2]
for(i in names){
if(i!="DensRaster"){
temp <- newStack[[i]][focalcell]/thisAbund    # get the population mean for key evolving variables
eval(parse(text=sprintf("FreqList[[\"%s\"]][focalcell]<-temp",i)))   # does this need a double arrow when in function? how to assign this to global environment
#assign(x=i,value=eval(parse(text=i)), envir = env)   # assign the variable to the global environment
}
}
assign(x="FreqList",value=eval(parse(text="FreqList")), envir = env)   # assign the variable to the global environment
overcrowded <- thisAbund>UserParams$Popbio$MAXABUND # if overcrowded, then dispersal will unfold in a certain way: e.g., colony will expand outward
if((overcrowded)){   # if focal cell is overcrowded
stay <- UserParams$Popbio$MAXDENS_HA-thisAbund  # number that should stay (here, negative so that individuals are removed)
newStack <- UpdateAbund(focalxy=xy,stack=newStack,df=as.data.frame(cbind(xy,stay)))   # keep the "stay" individuals in place
leave <- max(0,thisAbund-UserParams$Popbio$MAXABUND)
# expand the colony
newStack <- SpreadOut(newStack=newStack,leave_snuggle=leave,
plagueStatus=plagueStatus,xy=xy,neighborhood_raster=neighborhoodRasters[['abundRaster']],
neighborhood_mask_raster=neighborhoodRasters[['maskRaster']],
freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']],UserParams,env)
}
}
}
rm(list=ls())
############
## SIMULATION CONTROLS
############
NYEARS <- 5
############
## SET GLOBAL VARS
############
KEVIN_LAPTOP <- TRUE #  FALSE #
KEVIN_OFFICEPC <- FALSE # TRUE #
if(KEVIN_LAPTOP) GIT_DIR <- "C:\\Users\\Kevin\\GIT\\Plague_Resistance_Evolution"
if(KEVIN_OFFICEPC) GIT_DIR <- "E:\\GIT\\Plague_Resistance_Evolution"
#####################
# LOAD FUNCTIONS
#####################
setwd(GIT_DIR)
source("PlagueResistanceEvolution_FUNCTIONS.R")
############
## SET UP WORKSPACE AND LOAD PACKAGES
############
SetUpWorkspace()
num_cores <- detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
############
## SAMPLE FROM LATIN HYPERCUBE
############
N_LHS_SAMPLES <- 2
masterDF <- MakeLHSSamples(nicheBreadthDir=dir,NicheBreadth)
###########
##  START A PARALLEL FOR LOOP
###########
cl <- makeCluster(num_cores,outfile="LOG.TXT")
registerDoParallel(cl=cl)    # make the cluster
MakeWorker(NYEARS, masterDF, dirs)
MakeWorker(NYEARS, masterDF, dirs)(1)
dmat <- list()
dmat[[1]] <- matrix(c(1,0,0, 1,0,0), nrow=2,ncol=3,byrow = T)
dmat[[2]] <- matrix(c(1,1,0, 1,0,0), nrow=2,ncol=3,byrow = T)
dmat[[3]] <- matrix(c(1,0,0, 1,1,0), nrow=2,ncol=3,byrow = T)
dmat[[4]] <- matrix(c(1,1,0, 1,1,0), nrow=2,ncol=3,byrow = T)
UserParams <- DefineUserParams(PER_SUITABLE=masterDF$PER_SUITABLE[rep],SNUGGLE=masterDF$SNUGGLE[rep],NFOCI=1,MAXDISPERSAL=500,BASELINE_DISPERSAL=0.05,
MAXDISPERSAL_PLAGUE = 1000,PLAGUE_DISPERSAL=masterDF$PLAGUE_DISPERSAL[rep], MAXDENS = masterDF$MAXDENS[rep],
MINDENS = 15, BASELINE_MEANSURV = 0.6, BASELINE_PLAGUESURV=masterDF$BASELINE_PLAGUESURV[rep],
BASELINE_PLAGUESURV_RESIST=0.5,BASELINE_MEANFEC=masterDF$BASELINE_MEANFEC[rep],
FITNESS_COST=rep(masterDF$FITNESS_COST[rep],2),INITFREQ=rep(masterDF$INITFREQ[rep],2),DOMINANCE=dmat[[masterDF$DOMINANCE[rep]]])
rep=1
dmat <- list()
dmat[[1]] <- matrix(c(1,0,0, 1,0,0), nrow=2,ncol=3,byrow = T)
dmat[[2]] <- matrix(c(1,1,0, 1,0,0), nrow=2,ncol=3,byrow = T)
dmat[[3]] <- matrix(c(1,0,0, 1,1,0), nrow=2,ncol=3,byrow = T)
dmat[[4]] <- matrix(c(1,1,0, 1,1,0), nrow=2,ncol=3,byrow = T)
UserParams <- DefineUserParams(PER_SUITABLE=masterDF$PER_SUITABLE[rep],SNUGGLE=masterDF$SNUGGLE[rep],NFOCI=1,MAXDISPERSAL=500,BASELINE_DISPERSAL=0.05,
MAXDISPERSAL_PLAGUE = 1000,PLAGUE_DISPERSAL=masterDF$PLAGUE_DISPERSAL[rep], MAXDENS = masterDF$MAXDENS[rep],
MINDENS = 15, BASELINE_MEANSURV = 0.6, BASELINE_PLAGUESURV=masterDF$BASELINE_PLAGUESURV[rep],
BASELINE_PLAGUESURV_RESIST=0.5,BASELINE_MEANFEC=masterDF$BASELINE_MEANFEC[rep],
FITNESS_COST=rep(masterDF$FITNESS_COST[rep],2),INITFREQ=rep(masterDF$INITFREQ[rep],2),DOMINANCE=dmat[[masterDF$DOMINANCE[rep]]])
UserParams
InitializeDispersal <- function(UserParams){   # env
#UserParams <- get("UserParams",envir=env)
#browser()
UserParams$Dispersal$MAXDISPERSAL_CELLS <- floor(UserParams$Dispersal$MAXDISPERSAL_M/UserParams$Landscape$CELLWIDTH_M)
UserParams$Dispersal$MAXDISPERSAL_CELLS_PLAGUE <- floor(UserParams$Dispersal$MAXDISPERSAL_PLAGUE/UserParams$Landscape$CELLWIDTH_M)
UserParams$Dispersal$MAXDISPERSAL_M <- UserParams$Dispersal$MAXDISPERSAL_CELLS*UserParams$Landscape$CELLWIDTH_M
UserParams$Dispersal$MAXDISPERSAL_PLAGUE <- UserParams$Dispersal$MAXDISPERSAL_CELLS_PLAGUE*UserParams$Landscape$CELLWIDTH_M
DispMask <- list()
DispKernel <- list()
i="noPlague"
for(i in c("noPlague","plague")){
if(i=="noPlague"){ maxdispcells = UserParams$Dispersal$MAXDISPERSAL_CELLS ; maxdisp = UserParams$Dispersal$MAXDISPERSAL_M}
if(i=="plague") {maxdispcells = UserParams$Dispersal$MAXDISPERSAL_CELLS_PLAGUE ; maxdisp = UserParams$Dispersal$MAXDISPERSAL_PLAGUE}
tempDispMask <- matrix(1,nrow=((maxdispcells*2)+1),ncol=((maxdispcells*2)+1))     # dispersal mask defines where it is possible to go...
#DispMask_Plague <- matrix(1,nrow=((MAXDISPERSAL_CELLS_PLAGUE*2)+1),ncol=((MAXDISPERSAL_CELLS_PLAGUE*2)+1))     # dispersal mask defines where it is possible to go...
# exclude values greater than the max dispersal distance from the dispersal kernel
xs <- seq(UserParams$Landscape$HALFCELLWIDTH_M,maxdisp*2+UserParams$Landscape$HALFCELLWIDTH_M,by=UserParams$Landscape$CELLWIDTH_M)
ys <- seq(UserParams$Landscape$HALFCELLWIDTH_M,maxdisp*2+UserParams$Landscape$HALFCELLWIDTH_M,by=UserParams$Landscape$CELLWIDTH_M)
focalcell <- ((length(xs)-1)/2)+1
focalx <- xs[focalcell]
focaly <- ys[focalcell]
col=1;row=1
for(col in 1:length(xs)){
for(row in 1:length(ys)){
dist <- sqrt((xs[col]-focalx)^2 + (ys[row]-focaly)^2)
if(dist>maxdisp) tempDispMask[row,col] = NA
}
}
tempDispKernel <- tempDispMask   # for now, dispersal kernel is uniform    ; dispersal kernel defines where pdogs go if they lose a home colony
#DispKernel_Plague <- DispMask_Plague
DispMask[[i]] <- tempDispMask
DispKernel[[i]] <- tempDispKernel
}
# set up structures for colony expansion- individuals move to neighboring cells first..   [note: for now, donuts obey only the non-plague max dispersal]
donuts <- list()
j="noPlague"
for(j in c("noPlague","plague")){
if(j=="noPlague"){ maxdispcells = UserParams$Dispersal$MAXDISPERSAL_CELLS ; maxdisp = UserParams$Dispersal$MAXDISPERSAL_M}
if(j=="plague") {maxdispcells = UserParams$Dispersal$MAXDISPERSAL_CELLS_PLAGUE ; maxdisp = UserParams$Dispersal$MAXDISPERSAL_PLAGUE}
donuts[[j]] <- list()
donut_template <- matrix(0,nrow=((maxdispcells*2)+1),ncol=((maxdispcells*2)+1),byrow=T)
newseq <- c(-maxdispcells:maxdispcells)
ndx <- which(abs(newseq)<1)
donutsZero <- donut_template
donutsZero[ndx,ndx] <- 1
i=1
for(i in 1:maxdispcells){
ndx <- which(abs(newseq)<(i+1))
donuts[[j]][[i]] <- donut_template
donuts[[j]][[i]][ndx,ndx] <- 1
donuts[[j]][[i]] <- donuts[[j]][[i]] - donutsZero
#donuts[[i]] <- apply(donuts[[i]],c(1,2),function(t) ifelse(t==0,NA,t))
donutsZero <- donuts[[j]][[i]] + donutsZero
}
}
donuts[[j]] <- lapply(donuts[[j]],function(k) apply(k,c(1,2),function(t) ifelse(t==0,NA,t)))
#UserParams <- UserParams   # save to global environment
templist <- list()
templist$DispList <- list()
templist$DispList$donuts <- donuts
templist$DispList$DispMask <- DispMask
templist$DispList$DispKernel <- DispKernel
templist$UserParams <- UserParams
return(templist)
# assign(x="donuts",value=donuts, envir = env)
# assign(x="DispMask",value=DispMask, envir = env)
# assign(x="DispKernel",value=DispKernel, envir = env)
# assign(x="UserParams",value=UserParams, envir = env)
# donuts[['noPlague']][[4]]
}
DoInitialization <- function(UserParams,BaseLandscape){
#####################
# INITIALIZE DISPERSAL   (for both plague and no plague... )
#####################
temp <- InitializeDispersal(UserParams)   # env
UserParams <- temp$UserParams    #get("UserParams",envir=env)
DispList <- temp$DispList
########################
# INITIALIZE LANDSCAPE
########################
temp <- InitializeLandscape(solid=F,UserParams)   # generate patchmaps etc.  # env
UserParams <- temp$UserParams   #get("UserParams",envir=env)
BaseLandscape <- temp$BaseLandscape
########################
# GET PLAGUE MODEL
########################
suppressWarnings(  PlagueModel <- GetPlagueModel()  )  # for now, use fake plague model- will be a statistical model
#assign(x="PlagueModel",value=PlagueModel, envir = env)
########################
# INITIALIZE POPULATION
########################
InitDensRaster <- BaseLandscape$KRaster    # initialize abundance at carrying capacity
# plot(InitDensRaster)
#######################
# INITIALIZE ALLELE FREQUENCIES / RESISTANCE FACTORS [keep for now- will be multiple genes in the model somehow]
#######################
# NOTE: Some regions are more likely to evolve faster because they have greater percentages of those genes that can confer resistance.
InitFreqList <- GetInitFreqs(UserParams,BaseLandscape)
#assign(x="InitFreqList",value=InitFreqList, envir = env)
#####################
# INITIALIZE POPULATION
#####################
### Code block for pop starting from small loci
InitDensRaster2 <- reclassify(BaseLandscape$patchIDRaster,rcl=c(-Inf,Inf,0))    # for testing
ndx <- sample(which(!is.na(InitDensRaster2@data@values)),size=3)
InitDensRaster2[ndx] <- 1000   # initialize population in random locations
InitDensRaster <- InitDensRaster2
#PopArray2 <- InitDensRaster   # copy, for dispersal algorithm...
#assign(x="InitDensRaster",value=InitDensRaster, envir = env)
# PopArray <- GetStructuredPop(InitDensRaster,InitFreqList,UserParams,env)
# assign(x="PopArray",value=PopArray, envir = env)
#plot(PopArray)
######################
# INITIALIZE PLAGUE PROCESS   [KTS: moving away from this and towards a purely statistical model]
######################
#  for now, assume that plague hits at the patch level, and is a random process.
# PROB_PLAGUE_YEAR <- 0.5 # probability that a plague event hits (landscape level?)   # for now, plague only hits one patch in a plague year
#
# plagueyear = as.logical(rbinom(NYEARS,1,PROB_PLAGUE_YEAR))
#
# plagueNow = floor(runif(NYEARS,1,BaseLandscape$nPatches+1)) * as.numeric(plagueyear)    ## which patch plagues out?
PlagueRaster_template <- reclassify(BaseLandscape$patchIDRaster,rcl=c(-Inf,Inf,0))
#PlagueModel <- get("PlagueModel",envir=env)
PlagueRaster <- doPlague(PlagueRaster=PlagueRaster_template,
DensRaster=reclassify(BaseLandscape$patchIDRaster,rcl=c(-Inf,Inf,0)),UserParams,PlagueModel)
#assign(x="PlagueRaster",value=PlagueRaster, envir = env)
init.list <- list()
init.list$PlagueRaster <- PlagueRaster
#init.list$PopArray <- PopArray
init.list$InitFreqList <- InitFreqList
init.list$InitDensRaster <- InitDensRaster
init.list$PlagueModel <- PlagueModel
init.list$DispList <- DispList
return(init.list)
###########
# SAVE VARS TO GLOBAL ENVIRONMENT
###########
# plot(InitFreqList)
# plot(BaseLandscape$patchRaster)
# plot(BaseLandscape$patchIDRaster)
}
UserParams
InitList <- DoInitialization(UserParams,BaseLandscape)
# time step is one year
# consider scalar demographic model for now, but with potential for matrix model
# 8/29/16: changed to consider a binary resistance trait that is potentially a function of several gene loci...
############
## CLEAR WORKSPACE
############
rm(list=ls())
############
## SIMULATION CONTROLS
############
NYEARS <- 5
############
## SET GLOBAL VARS
############
KEVIN_LAPTOP <- TRUE #  FALSE #
KEVIN_OFFICEPC <- FALSE # TRUE #
if(KEVIN_LAPTOP) GIT_DIR <- "C:\\Users\\Kevin\\GIT\\Plague_Resistance_Evolution"
if(KEVIN_OFFICEPC) GIT_DIR <- "E:\\GIT\\Plague_Resistance_Evolution"
#####################
# LOAD FUNCTIONS
#####################
setwd(GIT_DIR)
source("PlagueResistanceEvolution_FUNCTIONS.R")
############
## SET UP WORKSPACE AND LOAD PACKAGES
############
SetUpWorkspace()
num_cores <- detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
############
## SAMPLE FROM LATIN HYPERCUBE
############
N_LHS_SAMPLES <- 2
masterDF <- MakeLHSSamples(nicheBreadthDir=dir,NicheBreadth)
###########
##  START A PARALLEL FOR LOOP
###########
cl <- makeCluster(num_cores,outfile="LOG.TXT")
registerDoParallel(cl=cl)    # make the cluster
rep=1
############
## USER-DEFINED VARIABLES
############
dmat <- list()
dmat[[1]] <- matrix(c(1,0,0, 1,0,0), nrow=2,ncol=3,byrow = T)
dmat[[2]] <- matrix(c(1,1,0, 1,0,0), nrow=2,ncol=3,byrow = T)
dmat[[3]] <- matrix(c(1,0,0, 1,1,0), nrow=2,ncol=3,byrow = T)
dmat[[4]] <- matrix(c(1,1,0, 1,1,0), nrow=2,ncol=3,byrow = T)
UserParams <- DefineUserParams(PER_SUITABLE=masterDF$PER_SUITABLE[rep],SNUGGLE=masterDF$SNUGGLE[rep],NFOCI=1,MAXDISPERSAL=500,BASELINE_DISPERSAL=0.05,
MAXDISPERSAL_PLAGUE = 1000,PLAGUE_DISPERSAL=masterDF$PLAGUE_DISPERSAL[rep], MAXDENS = masterDF$MAXDENS[rep],
MINDENS = 15, BASELINE_MEANSURV = 0.6, BASELINE_PLAGUESURV=masterDF$BASELINE_PLAGUESURV[rep],
BASELINE_PLAGUESURV_RESIST=0.5,BASELINE_MEANFEC=masterDF$BASELINE_MEANFEC[rep],
FITNESS_COST=rep(masterDF$FITNESS_COST[rep],2),INITFREQ=rep(masterDF$INITFREQ[rep],2),DOMINANCE=dmat[[masterDF$DOMINANCE[rep]]])
#assign(x="UserParams",value=UserParams, envir = env)
#
InitList <- DoInitialization(UserParams,BaseLandscape)
InitList
PlagueRaster <- InitList$PlagueRaster
InitFreqList <- InitList$InitFreqList
PlagueModel <- InitList$PlagueModel
DispList <- InitList$DispList
UserParams <- get("UserParams",envir=env)
BaseLandscape <- get("BaseLandscape",envir=env)
DoInitialization <- function(UserParams,BaseLandscape){
#####################
# INITIALIZE DISPERSAL   (for both plague and no plague... )
#####################
temp <- InitializeDispersal(UserParams)   # env
UserParams <- temp$UserParams    #get("UserParams",envir=env)
DispList <- temp$DispList
########################
# INITIALIZE LANDSCAPE
########################
temp <- InitializeLandscape(solid=F,UserParams)   # generate patchmaps etc.  # env
UserParams <- temp$UserParams   #get("UserParams",envir=env)
BaseLandscape <- temp$BaseLandscape
########################
# GET PLAGUE MODEL
########################
suppressWarnings(  PlagueModel <- GetPlagueModel()  )  # for now, use fake plague model- will be a statistical model
#assign(x="PlagueModel",value=PlagueModel, envir = env)
########################
# INITIALIZE POPULATION
########################
InitDensRaster <- BaseLandscape$KRaster    # initialize abundance at carrying capacity
# plot(InitDensRaster)
#######################
# INITIALIZE ALLELE FREQUENCIES / RESISTANCE FACTORS [keep for now- will be multiple genes in the model somehow]
#######################
# NOTE: Some regions are more likely to evolve faster because they have greater percentages of those genes that can confer resistance.
InitFreqList <- GetInitFreqs(UserParams,BaseLandscape)
#assign(x="InitFreqList",value=InitFreqList, envir = env)
#####################
# INITIALIZE POPULATION
#####################
### Code block for pop starting from small loci
InitDensRaster2 <- reclassify(BaseLandscape$patchIDRaster,rcl=c(-Inf,Inf,0))    # for testing
ndx <- sample(which(!is.na(InitDensRaster2@data@values)),size=3)
InitDensRaster2[ndx] <- 1000   # initialize population in random locations
InitDensRaster <- InitDensRaster2
#PopArray2 <- InitDensRaster   # copy, for dispersal algorithm...
#assign(x="InitDensRaster",value=InitDensRaster, envir = env)
# PopArray <- GetStructuredPop(InitDensRaster,InitFreqList,UserParams,env)
# assign(x="PopArray",value=PopArray, envir = env)
#plot(PopArray)
######################
# INITIALIZE PLAGUE PROCESS   [KTS: moving away from this and towards a purely statistical model]
######################
#  for now, assume that plague hits at the patch level, and is a random process.
# PROB_PLAGUE_YEAR <- 0.5 # probability that a plague event hits (landscape level?)   # for now, plague only hits one patch in a plague year
#
# plagueyear = as.logical(rbinom(NYEARS,1,PROB_PLAGUE_YEAR))
#
# plagueNow = floor(runif(NYEARS,1,BaseLandscape$nPatches+1)) * as.numeric(plagueyear)    ## which patch plagues out?
PlagueRaster_template <- reclassify(BaseLandscape$patchIDRaster,rcl=c(-Inf,Inf,0))
#PlagueModel <- get("PlagueModel",envir=env)
PlagueRaster <- doPlague(PlagueRaster=PlagueRaster_template,
DensRaster=reclassify(BaseLandscape$patchIDRaster,rcl=c(-Inf,Inf,0)),UserParams,PlagueModel)
#assign(x="PlagueRaster",value=PlagueRaster, envir = env)
init.list <- list()
init.list$PlagueRaster <- PlagueRaster
#init.list$PopArray <- PopArray
init.list$InitFreqList <- InitFreqList
init.list$InitDensRaster <- InitDensRaster
init.list$PlagueModel <- PlagueModel
init.list$DispList <- DispList
init.list$UserParams <- UserParams
return(init.list)
###########
# SAVE VARS TO GLOBAL ENVIRONMENT
###########
# plot(InitFreqList)
# plot(BaseLandscape$patchRaster)
# plot(BaseLandscape$patchIDRaster)
}
InitList <- DoInitialization(UserParams,BaseLandscape)
PlagueRaster <- InitList$PlagueRaster
InitFreqList <- InitList$InitFreqList
InitDensRaster <- InitList$InitDensRaster
PlagueModel <- InitList$PlagueModel
DispList <- InitList$DispList
UserParams <- InitList$UserParams
t=0
t=t+1
deviate <- rnorm(1)   #determine if this is a good year or a bad year (for now, survival and fecundity are perfectly correlated)
cv=UserParams$Popbio$CV_SURVIVAL   # set up for using the getYearVariate function
FreqList=InitFreqList; DensRaster=InitDensRaster; newFociRaster <- raster::reclassify(DensRaster,rcl=c(-Inf,Inf,0))     # initial conditions
FreqList=InitFreqList; DensRaster=InitDensRaster; newFociRaster <- raster::reclassify(DensRaster,rcl=c(-Inf,Inf,0))     # initial conditions
# time step is one year
# consider scalar demographic model for now, but with potential for matrix model
# 8/29/16: changed to consider a binary resistance trait that is potentially a function of several gene loci...
############
## CLEAR WORKSPACE
############
rm(list=ls())
############
## SIMULATION CONTROLS
############
NYEARS <- 5
############
## SET GLOBAL VARS
############
KEVIN_LAPTOP <- TRUE #  FALSE #
KEVIN_OFFICEPC <- FALSE # TRUE #
if(KEVIN_LAPTOP) GIT_DIR <- "C:\\Users\\Kevin\\GIT\\Plague_Resistance_Evolution"
if(KEVIN_OFFICEPC) GIT_DIR <- "E:\\GIT\\Plague_Resistance_Evolution"
#####################
# LOAD FUNCTIONS
#####################
setwd(GIT_DIR)
source("PlagueResistanceEvolution_FUNCTIONS.R")
############
## SET UP WORKSPACE AND LOAD PACKAGES
############
SetUpWorkspace()
num_cores <- detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
############
## SAMPLE FROM LATIN HYPERCUBE
############
N_LHS_SAMPLES <- 2
masterDF <- MakeLHSSamples(nicheBreadthDir=dir,NicheBreadth)
###########
##  START A PARALLEL FOR LOOP
###########
cl <- makeCluster(num_cores,outfile="LOG.TXT")
registerDoParallel(cl=cl)    # make the cluster
rep=1
