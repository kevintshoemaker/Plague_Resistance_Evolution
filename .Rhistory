if(t==1){ FreqList=InitFreqList; DensRaster=InitDensRaster}
doSurvival <- function(UserParams, DensRaster=InitDensRaster,PlagueRaster=PlagueRaster,Freqlist=FreqList){   # PopArray=PopArray
#thisPop <- getValues(PopArray)
thisPop <- GetStructuredPop(DensRaster,FreqList)    # break out population into resistant and non-resistant (and account for resistance factors)
# structuredFreq <- GetStructuredFreqList(DensRaster,FreqList)  # break out resistance factors into resistant and non-resistant
FCRaster <- FitnessCost(FreqList=InitFreqList)      # compute fitness costs
surv <- getSurvival(deviate,cv,FCRaster)    # get survival for all possible combinations of resistance and plague
###########
#  PERFORM SURVIVAL
###########
status="resistant"
for(status in c("resistant","susceptible")){
thisPop[[status]][PlagueRaster==1] <- thisPop[[status]][PlagueRaster==1]*surv[[status]][["plague"]][PlagueRaster==1]
thisPop[[status]][PlagueRaster==0] <- thisPop[[status]][PlagueRaster==0]*surv[[status]][["noPlague"]][PlagueRaster==0]
}
##########
#  DEMOGRAPHIC STOCHASTICITY
##########
for(status in c("resistant","susceptible")){
thisPop[[status]] <- calc(thisPop[[status]],fun=demographicStoch)
}
##########
#  REVERT TO UNSTRUCTURED POPULATION
##########
NewDensRaster <- GetUnstructuredPop(thisPop,FreqList)    # break out population into resistant and non-resistant (and account for genes/resistance factors)
return(NewDensRaster)
}
DensRaster <- doSurvival(UserParams,DensRaster,PlagueRaster,FreqList)
plot(reslist)
plot(FreqList)
DensRaster <- doReproduce(UserParams,DensRaster,PlagueRaster = PlagueRaster)    # TODO: make specific to each resistance type...?
library("raster")
library("secr")
library("igraph")
UserParams$Dispersal$BASELINE_DISPERSAL
GetDispersalRates <- function(plagueStatus="noPlague"){
if(plagueStatus=="noPlague") {maxdisp<<-UserParams$Dispersal$MAXDISPERSAL_M;disprate<<-UserParams$Dispersal$BASELINE_DISPERSAL;maxdispcells<<-UserParams$Dispersal$MAXDISPERSAL_CELLS}
if(plagueStatus=="plague") {maxdisp<<-UserParams$Dispersal$MAXDISPERSAL_PLAGUE;disprate<<-UserParams$Dispersal$PLAGUE_DISPERSAL;maxdispcells<<-UserParams$Dispersal$MAXDISPERSAL_CELLS_PLAGUE}
}
UserParams$Popbio$MAXABUND
UserParams$Popbio$MAXDENS_HA
makeNeighborhoodRasters <- function(newStack=newStack,plagueStatus="noPlague",xy=xy){
mask=DispMask[[plagueStatus]]
kernel=DispKernel[[plagueStatus]]
GetDispersalRates(plagueStatus) # already done...
neighborhood.extent <- extent(xy$x-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$x+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M,
xy$y-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$y+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M)
neighborhood_raster <- crop(newStack[["PopArray"]],neighborhood.extent)    # possible cells to move to and from [TODO: change this to current status, not former]
#neighborhood_raster <- neighborhood_raster - (neighborhood_raster*disprate) # make sure that there is space for incoming dispersers [revisit this]
################
# Make a neighborhood mask
vals <- as.vector(t(mask))  # convert disp mask to a vector format
#vals[vals==0] <- NA
#neighborhood_kernel_raster <- neighborhood_raster
length(vals)
ncell(neighborhood_raster)
neighborhood_mask_raster <- setValues(neighborhood_raster,values=vals)  # NOTE: this could be a dispersal kernel
###############
# Make a neighborhood kernel
vals <- as.vector(t(kernel))
neighborhood_kernel_raster <- setValues(neighborhood_raster,values=vals)
#     plot(neighborhood_raster)
#     plot(neighborhood_mask_raster)
neighborhood_raster <- neighborhood_raster * neighborhood_mask_raster  # abundance in real neighborhood (assuming edge is hard barrier)
neighborhood_mask_raster <- reclassify(neighborhood_raster,c(-Inf,Inf,1))
neighborhood_kernel_raster <- neighborhood_kernel_raster*neighborhood_mask_raster
# names(neighborhoodRasters)
freeSpace_raster <- reclassify(UserParams$Popbio$MAXDENS_HA-neighborhood_raster,rcl=c(-Inf,0,0))  # indicator of how much "free space" is available for cells in the neighborhood
# plot(freeSpace_raster)
neighborhood_stack <- stack(list(
maskRaster = neighborhood_mask_raster,
kernelRaster = neighborhood_kernel_raster,
abundRaster = neighborhood_raster,
freeSpaceRaster = freeSpace_raster
))
return(neighborhood_stack)
}
UserParams$Popbio$MAXDENS_HA
SpreadOut <- function(newStack=newStack,leave_snuggle=leave_snuggle,
plagueStatus=plagueStatus,
xy=xy,
neighborhood_raster=neighborhoodRasters[['abundRaster']],
neighborhood_mask_raster=neighborhoodRasters[['maskRaster']],
freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']]){
GetDispersalRates(plagueStatus=plagueStatus)
updatedStack <- newStack
i=2
#toAdd <- data.frame(x=numeric(0),y=numeric(0))
for(i in 1:maxdispcells){
donutraster <- setValues(neighborhood_raster,values=donuts[[plagueStatus]][[i]])
# plot(donutraster)
#tempmask <- reclassify(neighborhood_raster,rcl=c(-Inf,Inf,1))  # NA,NA,0,
#browser()
donutraster <- donutraster*neighborhood_mask_raster  # all non-NA cells within the donut
#         plot(donutraster+tempmask)
#         plot(donutraster)
#         plot(tempmask)
#         plot(neighborhood_mask_raster)
#         plot(donutraster==tempmask)
#         plot(freeSpace_raster)
temp <- freeSpace_raster*donutraster
#plot(reclassify(neighborhood_raster,rcl=c(-Inf,Inf,1)))
#temp <- reclassify(MAXABUND-temp,rcl=c(-Inf,0,0))   # REVISIT!
# plot(temp)
freeSpace <- temp@data@values[which(temp@data@values>0)]
# if there is free space... then put individuals in that space...
if(length(freeSpace)>0){
toAdd_df <- as.data.frame(xyFromCell(temp,which(temp@data@values>0))) # cells with empty space to go
# allocate those individuals
#toAdd_df$indiv <- 0
toAdd <- min(sum(freeSpace),leave_snuggle)
toAdd_df$indiv <- rmultinom(1,toAdd,prob=freeSpace)[,1]    # disperser individuals to add to each cell
dispndx <- which(toAdd_df$indiv>0)
updatedStack <- UpdateAbund(focalxy=xy,stack=updatedStack,df=toAdd_df[dispndx,])  # add these disperser individuals and update the evolving factors
leave_snuggle <- leave_snuggle-toAdd   # remove these individuals from the "leave" pool
#ndx <- cellFromXY(newPop,toAdd_df[,c("x","y")])
#newPop[ndx] <- newPop[ndx]+toAdd_df$indiv
# plot(newPop)
# plot(updatedStack[["PopArray"]])
} # end if free space available
# if all individuals have been dispersed, then stop the loop
if(leave_snuggle<=0) break
#if(i==MAXDISPERSAL_CELLS) # don't need to kill off the existing individuals explicitly... they automatically don't get propagated...
} #end loop through donuts
return(updatedStack)
}
#names(neighborhoodRasters)
LongDistanceDispersal <- function(newStack=newStack,leave_kernel=leave_kernel,
plagueStatus=plagueStatus,
xy=xy,
neighborhood_raster=neighborhoodRasters[['abundRaster']],
freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']],
neighborhood_kernel_raster=neighborhoodRasters[['kernelRaster']]){
# disperse via the kernel...
#leave_kernel
#plot(neighborhood_raster)
#plot(reclassify(neighborhood_raster,rcl=c(-Inf,Inf,1)))
GetDispersalRates(plagueStatus=plagueStatus)
freeSpace <-  freeSpace_raster@data@values[which(freeSpace_raster@data@values>0)]
if(length(freeSpace)>0){
freeSpace <- (freeSpace+1)/max(freeSpace)  # convert to weighting factor in line with kernel
toAdd_df <- as.data.frame(xyFromCell(freeSpace_raster,which(freeSpace_raster@data@values>0))) # cells with empty space and habitat to go
kernel.weights <- neighborhood_kernel_raster[cellFromXY(neighborhood_kernel_raster,toAdd_df[,c(1,2)])]
# allocate those individuals
#toAdd_df$indiv <- 0
#toAdd <- min(sum(freeSpace),leave_kernel)
toAdd_df$indiv <- rmultinom(1,leave_kernel,prob=freeSpace*kernel.weights)[,1]    # disperser individuals to add to each cell (favor cells that have more free space...)
}else{  # if there is no free space, then force dispersal anyway
toAdd_df <- as.data.frame(xyFromCell(neighborhood_raster,which(!is.na(neighborhood_raster@data@values)))) # cells with habitat to go
kernel.weights <- neighborhood_kernel_raster[cellFromXY(neighborhood_kernel_raster,toAdd_df[,c(1,2)])]
# allocate those individuals
#toAdd_df$indiv <- 0
#toAdd <- min(sum(freeSpace),leave_kernel)
toAdd_df$indiv <- rmultinom(1,leave_kernel,prob=kernel.weights)[,1]    # disperser individuals to add to each cell (favor cells that have more free space...)
}
dispndx <- which(toAdd_df$indiv>0)
updatedStack <- UpdateAbund(focalxy=xy,stack=newStack,df=toAdd_df[dispndx,])  # add these disperser individuals and update the accumulating raster stack
#leave_kernel <- leave_kernel-toAdd   # remove these individuals from the "leave" pool
#ndx <- cellFromXY(newPop,toAdd_df[,c("x","y")])
#newPop[ndx] <- newPop[ndx]+toAdd_df$indiv
# plot(newPop)
return(updatedStack)
}
#names(neighborhoodRasters)
ConsolidatePops <- function(newStack=newStack,leave=leave,
#newFociRaster=newFociRaster,
plagueStatus=plagueStatus,
xy=xy,
newFociRaster=newFociRaster,
neighborhood_raster=neighborhoodRasters[['abundRaster']],
neighborhood_mask_raster=neighborhoodRasters[['maskRaster']]){
GetDispersalRates(plagueStatus=plagueStatus)
# plot(newFociRaster)
tempFociRaster <- crop(newFociRaster,extent(neighborhood_mask_raster))
# plot(tempFociRaster)
localfoci <- as.data.frame(xyFromCell(tempFociRaster,which(tempFociRaster@data@values==1)))   # data frame of local foci
nlocalfoci <- nrow(localfoci)              # number of existing new foci in the area
if(nlocalfoci>UserParams$Dispersal$NFOCI) localfoci <- localfoci[sample(c(1:nlocalfoci),UserParams$Dispersal$NFOCI),]   # if multiple local foci, reduce the number of foci to NFOCI
newfocineeded <- max(0,UserParams$Dispersal$NFOCI-nlocalfoci)  # new foci needed
if(newfocineeded>0){
candidates <- neighborhood_raster@data@values   # candidates as new foci
candidates[candidates>UserParams$Popbio$MINDENS_HA] <- 0   # discount cells that are already fairly full  [note, if no cells are below minimum abundace, then another cell will be selected!]
candidates[candidates==0] <- 1
for(i in 1:newfocineeded){
localfoci <- rbind(localfoci,as.data.frame(xyFromCell(tempFociRaster,which.max(candidates))))
candidates[which.max(candidates)] <- 0
}
}
allocation <- rmultinom(1,leave,c(1:UserParams$Dispersal$NFOCI))[,1]
localfoci$indiv <- allocation
updatedStack <- UpdateAbund(focalxy=xy,stack=newStack,df=localfoci)     # move new individuals to local foci
## update foci
ndx <- cellFromXY(newFociRaster,localfoci[,c(1,2)])
newFociRaster[ndx] <- 1
assign(x="newFociRaster",value=newFociRaster,envir=.GlobalEnv)
# plot(newFociRaster)
return(updatedStack)
}
stayFunction <- function(x,y){
#browser()
disprate = ifelse(y==1,UserParams$Dispersal$PLAGUE_DISPERSAL,UserParams$Dispersal$BASELINE_DISPERSAL)   # NOTE: this creates "donut holes" in colonies where plague has been...
value <- ifelse(x>UserParams$Popbio$MAXDENS_HA,round(UserParams$Popbio$MAXDENS_HA*(1-disprate)),round(x*(1-disprate)))
value2 <- ifelse(x<UserParams$Popbio$MINDENS_HA,0,value)
#if(any(!is.na(c))) value[!is.na(c)] <-   #rpois(length(which(!is.na(c))),c[!is.na(c)])
return(value2)
}
UserParams
PlagueRaster
FreqList
## build up the results for dispersal
newStack <- stack(list(
DensRaster = reclassify(DensRaster,rcl=c(-Inf,Inf,0)),   # blank raster for filling in the dispersal
FreqList = reclassify(FreqList,rcl=c(-Inf,Inf,0))   # blank raster for filling in the plague survival
))    # raster stack that is updated during the dispersal process...
newStack
names(newStack)
newFreqList <- reclassify(FreqList,rcl=c(-Inf,Inf,0))
newFreqList
FreqList
newFreqList <- FreqList
FreqList[[i]]
FreqList[[1]]
for(i in 1:length(names(FreqList))){
FreqList[[i]] <- reclassify(FreqList[[i]],rcl=c(-Inf,Inf,0))
}
FreqList <- InitFreqList
newFreqList <- FreqList
for(i in 1:length(names(FreqList))){
newFreqList[[i]] <- reclassify(FreqList[[i]],rcl=c(-Inf,Inf,0))
}
newFreqList
FreqList
newFreqList <- reclassify(FreqList[[i]],rcl=c(-Inf,Inf,0))
names(newFreqList) <- names(FreqList)
newFreqList
newFreqList <- reclassify(FreqList,rcl=c(-Inf,Inf,0))
names(newFreqList) <- names(FreqList)
newFreqList
stayRaster <- overlay(DensRaster,PlagueRaster,fun=stayFunction)
stayRaster[stayRaster<50]
leaveRaster <- DensRaster-stayRaster   # everyone that didn't stay has to leave!
rasterNames
geneNames <- names(FreqList)
geneNames
for(n in geneNames){
newFreqList[[n]][stayRaster>0] <- FreqList[[n]][stayRaster>0]*stayRaster[stayRaster>0]     # stayers contribute to post-dispersal allele frequenceis
# plot(eval(parse(text=n)))
# plot(eval(parse(text=n))*stayRaster)
# plot(newStack[[n]])
# extent <- drawExtent()
# plot(crop(stayRaster,extent))   # okay this is actually working
}
newFreqList
focalCells <- which(leaveRaster@data@values>0)   # identify cells with dispersers leaving
xy_df <- data.frame(
xyFromCell(patchRaster,focalCells)
)
xy_df <- xy_df[sample(c(1:nrow(xy_df))),]
xy_df
counter <- 1
focalcell <- focalCells[counter]  # cell from which to draw potential dispersers
focalcell
focalCells
xy <- xy_df[counter,]
xy
plagueStatus <- ifelse(PlagueRaster[focalcell]==1,"plague","noPlague")   # determine if plague
GetDispersalRates(plagueStatus = plagueStatus)  # get the current dispersal rates
neighborhoodRasters <- makeNeighborhoodRasters(newStack=newStack,plagueStatus = plagueStatus, xy=xy)  # characterize the possible sites to move to in the neighborhood
plagueStatus
View(makeNeighborhoodRasters)
newStack
mask=DispMask[[plagueStatus]]
kernel=DispKernel[[plagueStatus]]
GetDispersalRates(plagueStatus) # already done...
neighborhood.extent <- extent(xy$x-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$x+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M,
xy$y-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$y+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M)
neighborhood_raster <- crop(newStack[["PopArray"]],neighborhood.extent)    # possible cells to move to and from [TODO: change this to current status, not former]
neighborhood_raster <- crop(newDensRaster,neighborhood.extent)    # possible cells to move to and from [TODO: change this to current status, not former]
newDensRaster <- reclassify(DensRaster,rcl=c(-Inf,Inf,0))   # blank raster for filling in the dispersal
newFreqList <- reclassify(FreqList,rcl=c(-Inf,Inf,0))
names(newFreqList) <- names(FreqList)
stayRaster <- overlay(DensRaster,PlagueRaster,fun=stayFunction)
leaveRaster <- DensRaster-stayRaster   # everyone that didn't stay has to leave!
geneNames <- names(FreqList)
n
for(n in geneNames){
newFreqList[[n]][stayRaster>0] <- FreqList[[n]][stayRaster>0]*stayRaster[stayRaster>0]     # stayers contribute to post-dispersal allele frequenceis
# plot(eval(parse(text=n)))
# plot(eval(parse(text=n))*stayRaster)
# plot(newStack[[n]])
# extent <- drawExtent()
# plot(crop(stayRaster,extent))   # okay this is actually working
}
focalCells <- which(leaveRaster@data@values>0)   # identify cells with dispersers leaving
xy_df <- data.frame(
xyFromCell(patchRaster,focalCells)
)
# reshuffle the order (make foci of expansion a bit more random...)
xy_df <- xy_df[sample(c(1:nrow(xy_df))),]
# head
counter <- 1
focalcell <- focalCells[counter]
xy <- xy_df[counter,]
plagueStatus <- ifelse(PlagueRaster[focalcell]==1,"plague","noPlague")   # determine if plague
GetDispersalRates(plagueStatus = plagueStatus)  # get the current dispersal rates
mask=DispMask[[plagueStatus]]
kernel=DispKernel[[plagueStatus]]
GetDispersalRates(plagueStatus) # already done...
neighborhood.extent <- extent(xy$x-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$x+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M,
xy$y-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$y+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M)
neighborhood_raster <- crop(newDensRaster,neighborhood.extent)
vals <- as.vector(t(mask))  # convert disp mask to a vector format
#vals[vals==0] <- NA
#neighborhood_kernel_raster <- neighborhood_raster
length(vals)
ncell(neighborhood_raster)
neighborhood_mask_raster <- setValues(neighborhood_raster,values=vals)  # NOTE: this could be a dispersal kernel
vals <- as.vector(t(kernel))
neighborhood_kernel_raster <- setValues(neighborhood_raster,values=vals)
#     plot(neighborhood_raster)
#     plot(neighborhood_mask_raster)
neighborhood_raster <- neighborhood_raster * neighborhood_mask_raster  # abundance in real neighborhood (assuming edge is hard barrier)
neighborhood_mask_raster <- reclassify(neighborhood_raster,c(-Inf,Inf,1))
neighborhood_kernel_raster <- neighborhood_kernel_raster*neighborhood_mask_raster
freeSpace_raster <- reclassify(UserParams$Popbio$MAXDENS_HA-neighborhood_raster,rcl=c(-Inf,0,0))  # indicator of how much "free space" is available for cells in the neighborhood
makeNeighborhoodRasters <- function(newDensRaster,newFreqList=newFreqList,plagueStatus="noPlague",xy=xy){
mask=DispMask[[plagueStatus]]
kernel=DispKernel[[plagueStatus]]
GetDispersalRates(plagueStatus) # already done...
neighborhood.extent <- extent(xy$x-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$x+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M,
xy$y-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$y+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M)
neighborhood_raster <- crop(newDensRaster,neighborhood.extent)    # possible cells to move to and from [TODO: change this to current status, not former]
#neighborhood_raster <- neighborhood_raster - (neighborhood_raster*disprate) # make sure that there is space for incoming dispersers [revisit this]
################
# Make a neighborhood mask
vals <- as.vector(t(mask))  # convert disp mask to a vector format
#vals[vals==0] <- NA
#neighborhood_kernel_raster <- neighborhood_raster
length(vals)
ncell(neighborhood_raster)
neighborhood_mask_raster <- setValues(neighborhood_raster,values=vals)  # NOTE: this could be a dispersal kernel
###############
# Make a neighborhood kernel
vals <- as.vector(t(kernel))
neighborhood_kernel_raster <- setValues(neighborhood_raster,values=vals)
#     plot(neighborhood_raster)
#     plot(neighborhood_mask_raster)
neighborhood_raster <- neighborhood_raster * neighborhood_mask_raster  # abundance in real neighborhood (assuming edge is hard barrier)
neighborhood_mask_raster <- reclassify(neighborhood_raster,c(-Inf,Inf,1))
neighborhood_kernel_raster <- neighborhood_kernel_raster*neighborhood_mask_raster
# names(neighborhoodRasters)
freeSpace_raster <- reclassify(UserParams$Popbio$MAXDENS_HA-neighborhood_raster,rcl=c(-Inf,0,0))  # indicator of how much "free space" is available for cells in the neighborhood
# plot(freeSpace_raster)
neighborhood_stack <- stack(list(
maskRaster = neighborhood_mask_raster,
kernelRaster = neighborhood_kernel_raster,
abundRaster = neighborhood_raster,
freeSpaceRaster = freeSpace_raster
))
return(neighborhood_stack)
}
GetDispersalRates(plagueStatus = plagueStatus)  # get the current dispersal rates
plagueStatus <- ifelse(PlagueRaster[focalcell]==1,"plague","noPlague")   # determine if plague
neighborhoodRasters <- makeNeighborhoodRasters(newStack=newStack,plagueStatus = plagueStatus, xy=xy)  # characterize the possible sites to move to in the neighborhood
neighborhoodRasters <- makeNeighborhoodRasters(newDensRaster,newFreqList,plagueStatus = plagueStatus, xy=xy)  # characterize the possible sites to move to in the neighborhood
thisAbund <- as.numeric(DensRaster[focalcell])  # abundance in the focal cell
overcrowded <- thisAbund>UserParams$Popbio$MAXABUND # if overcrowded, then dispersal will unfold in a certain way: e.g., colony will expand outward
undercrowded <- thisAbund<UserParams$Popbio$MINABUND  # if undercrowded, then dispersal can unfold in a different way: e.g., colony will restructure and group together at new focal areas
stay <- stayRaster[focalcell]
leave <- leaveRaster[focalcell]
overcrowded
if(plagueStatus=="plague") leave_snuggle <- 0
if(plagueStatus=="noPlague") leave_snuggle <- floor(leave*UserParams$Dispersal$SNUGGLE)   # these individuals will try to find a place to settle next door
leave_kernel <- leave-leave_snuggle     # these individuals will obey the dispersal kernel
newDensRaster
newDensRaster
newDensRaster <- reclassify(DensRaster,rcl=c(-Inf,Inf,0))   # blank raster for filling in the dispersal
newFreqList <- reclassify(FreqList,rcl=c(-Inf,Inf,0))
names(newFreqList) <- names(FreqList)
newStack <- list(DensRaster=newDensRaster,
FreqList=FreqList)
newStack
stack(newStack)
newDensRaster <- reclassify(DensRaster,rcl=c(-Inf,Inf,0))   # blank raster for filling in the dispersal
newFreqList <- reclassify(FreqList,rcl=c(-Inf,Inf,0))
names(newFreqList) <- names(FreqList)
newStack <- list(DensRaster=newDensRaster,
FreqList=FreqList)
newStack <- stack(newStack)
stayRaster <- overlay(DensRaster,PlagueRaster,fun=stayFunction)
leaveRaster <- DensRaster-stayRaster   # everyone that didn't stay has to leave!
geneNames <- names(FreqList)
for(n in geneNames){
newFreqList[[n]][stayRaster>0] <- FreqList[[n]][stayRaster>0]*stayRaster[stayRaster>0]     # stayers contribute to post-dispersal allele frequenceis
# plot(eval(parse(text=n)))
# plot(eval(parse(text=n))*stayRaster)
# plot(newStack[[n]])
# extent <- drawExtent()
# plot(crop(stayRaster,extent))   # okay this is actually working
}
geneNames
for(n in geneNames){
newStack[[n]][stayRaster>0] <- newStack[[n]][stayRaster>0]*stayRaster[stayRaster>0]     # stayers contribute to post-dispersal allele frequenceis
# plot(eval(parse(text=n)))
# plot(eval(parse(text=n))*stayRaster)
# plot(newStack[[n]])
# extent <- drawExtent()
# plot(crop(stayRaster,extent))   # okay this is actually working
}
focalCells <- which(leaveRaster@data@values>0)   # identify cells with dispersers leaving
xy_df <- data.frame(
xyFromCell(patchRaster,focalCells)
)
xy_df <- xy_df[sample(c(1:nrow(xy_df))),]
xy_df
counter <- 1
focalcell <- focalCells[counter]  # cell from which to draw potential dispersers
xy <- xy_df[counter,]
plagueStatus <- ifelse(PlagueRaster[focalcell]==1,"plague","noPlague")   # determine if plague
GetDispersalRates(plagueStatus = plagueStatus)  # get the current dispersal rates
neighborhoodRasters <- makeNeighborhoodRasters(newDensRaster,newFreqList,plagueStatus = plagueStatus, xy=xy)  # characterize the possible sites to move to in the neighborhood
newStack
stayRaster>0
newStack[['DensRaster']] <- stayRaster   # update the new DensRaster with the known stayers. This deals with all "stay" individuals so that only leavers must be considered
newStack
focalCells <- which(leaveRaster@data@values>0)   # identify cells with dispersers leaving
xy_df <- data.frame(
xyFromCell(patchRaster,focalCells)
)
# reshuffle the order (make foci of expansion a bit more random...)
xy_df <- xy_df[sample(c(1:nrow(xy_df))),]
counter <- 1
focalcell <- focalCells[counter]  # cell from which to draw potential dispersers
focalcell
xy <- xy_df[counter,]
plagueStatus <- ifelse(PlagueRaster[focalcell]==1,"plague","noPlague")   # determine if plague
GetDispersalRates(plagueStatus = plagueStatus)  # get the current dispersal rates
neighborhoodRasters <- makeNeighborhoodRasters(newStack,plagueStatus = plagueStatus, xy=xy)  # characterize the possible sites to move to in the neighborhood
mask=DispMask[[plagueStatus]]
kernel=DispKernel[[plagueStatus]]
GetDispersalRates(plagueStatus) # already done...
neighborhood.extent <- extent(xy$x-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$x+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M,
xy$y-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$y+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M)
neighborhood_raster <- crop(newStack[["DensRaster"]],neighborhood.extent)    # possible cells to move to and from [TODO: change this to current status, not former]
makeNeighborhoodRasters <- function(newStack,plagueStatus="noPlague",xy=xy){
mask=DispMask[[plagueStatus]]
kernel=DispKernel[[plagueStatus]]
GetDispersalRates(plagueStatus) # already done...
neighborhood.extent <- extent(xy$x-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$x+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M,
xy$y-maxdisp-UserParams$Landscape$HALFCELLWIDTH_M,
xy$y+maxdisp+UserParams$Landscape$HALFCELLWIDTH_M)
neighborhood_raster <- crop(newStack[["DensRaster"]],neighborhood.extent)    # possible cells to move to and from [TODO: change this to current status, not former]
#neighborhood_raster <- neighborhood_raster - (neighborhood_raster*disprate) # make sure that there is space for incoming dispersers [revisit this]
################
# Make a neighborhood mask
vals <- as.vector(t(mask))  # convert disp mask to a vector format
#vals[vals==0] <- NA
#neighborhood_kernel_raster <- neighborhood_raster
length(vals)
ncell(neighborhood_raster)
neighborhood_mask_raster <- setValues(neighborhood_raster,values=vals)  # NOTE: this could be a dispersal kernel
###############
# Make a neighborhood kernel
vals <- as.vector(t(kernel))
neighborhood_kernel_raster <- setValues(neighborhood_raster,values=vals)
#     plot(neighborhood_raster)
#     plot(neighborhood_mask_raster)
neighborhood_raster <- neighborhood_raster * neighborhood_mask_raster  # abundance in real neighborhood (assuming edge is hard barrier)
neighborhood_mask_raster <- reclassify(neighborhood_raster,c(-Inf,Inf,1))
neighborhood_kernel_raster <- neighborhood_kernel_raster*neighborhood_mask_raster
# names(neighborhoodRasters)
freeSpace_raster <- reclassify(UserParams$Popbio$MAXDENS_HA-neighborhood_raster,rcl=c(-Inf,0,0))  # indicator of how much "free space" is available for cells in the neighborhood
# plot(freeSpace_raster)
neighborhood_stack <- stack(list(
maskRaster = neighborhood_mask_raster,
kernelRaster = neighborhood_kernel_raster,
abundRaster = neighborhood_raster,
freeSpaceRaster = freeSpace_raster
))
return(neighborhood_stack)
}
xy <- xy_df[counter,]
plagueStatus <- ifelse(PlagueRaster[focalcell]==1,"plague","noPlague")   # determine if plague
GetDispersalRates(plagueStatus = plagueStatus)  # get the current dispersal rates
neighborhoodRasters <- makeNeighborhoodRasters(newStack,plagueStatus = plagueStatus, xy=xy)  # characterize the possible sites to move to in the neighborhood
thisAbund <- as.numeric(DensRaster[focalcell])  # abundance in the focal cell
neighborhoodRasters
thisAbund <- as.numeric(DensRaster[focalcell])  # abundance in the focal cell
overcrowded <- thisAbund>UserParams$Popbio$MAXABUND # if overcrowded, then dispersal will unfold in a certain way: e.g., colony will expand outward
undercrowded <- thisAbund<UserParams$Popbio$MINABUND  # if undercrowded, then dispersal can unfold in a different way: e.g., colony will restructure and group together at new focal areas
stay <- stayRaster[focalcell]
leave <- leaveRaster[focalcell]
overcrowded
if(plagueStatus=="plague") leave_snuggle <- 0
if(plagueStatus=="noPlague") leave_snuggle <- floor(leave*UserParams$Dispersal$SNUGGLE)   # these individuals will try to find a place to settle next door
leave_kernel <- leave-leave_snuggle     # these individuals will obey the dispersal kernel
newStack <- SpreadOut(newStack=newStack,leave_snuggle=leave_snuggle,
plagueStatus=plagueStatus,xy=xy,neighborhood_raster=neighborhoodRasters[['abundRaster']],
neighborhood_mask_raster=neighborhoodRasters[['maskRaster']],
freeSpace_raster=neighborhoodRasters[['freeSpaceRaster']])
newStack
